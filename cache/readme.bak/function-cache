<h1>function-cache</h1>

<p>A common lisp library that provides extensible function result caching
based on arguments (an expanded form of memoization).</p>

<h2>Differences from fare-memoization</h2>

<ul>
<li>By default uses separate tables for each function</li>
<li>Supports other cache structures (eg: optimization for thunks, mru-heaps)</li>
<li>Supports optional caching for functions that are called in transient
   cache contexts (eg: http-context, web application session etc)</li>
<li>Supports timeouts to invalidate caches, and purging of expired
   cached results</li>
<li>A more robust cache clearing scheme, clear all caches, all caches
   in a package, or just a specific cache</li>
</ul>

<h2>API</h2>

<h3>DEFCACHED</h3>

<p>Creates a cached function named SYMBOL and a cache object named <code>*{FN-NAME}-CACHE*</code>
SYMBOL can also be a list</p>

<p><code>(FN-NAME &amp;rest cache-init-args
   &amp;key CACHE-CLASS TABLE TIMEOUT SHARED-RESULTS?)</code></p>

<ul>
<li>CACHE-CLASS - controls what cache class will be instantiated (uses
   default-cache-class if not provided)</li>
<li>TABLE - a shared cache-store to use, usually a hash-table, a function that returns
   a hashtable, or a symbol whose value is a hash-table</li>
<li>TIMEOUT - how long entries in the cache should be considered valid for, in seconds</li>
<li>SHARED-RESULTS? - do we expect that we are sharing cache space with other things
   defaults to t if TABLE is provided</li>
</ul>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defcached</span></i> symbol <span class="paren2">(<span class="code">lambda-list</span>)</span> ...</span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defcached</span></i> <span class="paren2">(<span class="code">symbol &amp;key table cache-class timeout shared-results?</span>)</span> <span class="paren2">(<span class="code">lambda-list</span>)</span> ...</span>)</span>
EG:

<span class="paren1">(<span class="code"><i><span class="symbol">defcached</span></i> <span class="paren2">(<span class="code">foo <span class="keyword">:timeout</span> 10</span>)</span> <span class="paren2">(<span class="code">arg0</span>)</span>
  <span class="paren2">(<span class="code">sleep 3</span>)</span>
  arg0</span>)</span>
<span class="paren1">(<span class="code">foo 1</span>)</span> <span class="comment">;; waits 3s then returns 1
</span><span class="paren1">(<span class="code">foo 1</span>)</span> <span class="comment">;; returns 1 immediately
</span><span class="paren1">(<span class="code">foo 0</span>)</span> <span class="comment">;; waits 3s then returns 0
</span><span class="paren1">(<span class="code">foo 0</span>)</span> <span class="comment">;; returns 0 immediately
</span><span class="paren1">(<span class="code">foo 2</span>)</span> <span class="comment">;; waits 3s then returns 2
</span><span class="paren1">(<span class="code">foo 3</span>)</span> <span class="comment">;; waits 3s then returns 3
</span><span class="paren1">(<span class="code">foo 1</span>)</span> <span class="comment">;; has timedout, waits 3s then returns 1</span></span></code></pre>

<h4>Cache-objects and Names</h4>

<p>Each cached function will have a cache object associated with it in
special-variable <code>*{FN-NAME}-CACHE*</code>.  You can find a cache object for
a function name using <code>find-function-cache-for-name</code> if necessary.  In
most of the api, a function-name or a cache-object should be
interchangable.</p>

<h3>function-cache, thunk-cache, hash-table-function-cache, single-cell-function-cache</h3>

<p>The basic types of function-caches currently provided.
 * Function-cache - abstract class for all function-caches
 * thunk-cache - a cache specialized for storing the results of thunks
  * automatically chosen, for functions of 0 args
 * hash-table-function-cache
  * A hash-table backed function-cache, supports shared hash-tables, but defaults
    to a unique hash-table for each cache
  * Supports dynamically available caching (eg: web-request contexts),
    by setting cache-results to a function or symbol that will
    possibly return a hashtable. If either of these return nil, then
    caching is bypassed for that call
 * single-cell-function-cache
  * caches the single most recently used call
 * lru-cache
  * A cache with a fixed capacity
  * Backed by a combination of a hash table and doubly-linked list
  * When the maximimum capacity is reached the least recently used cache
    entries are deleted.
 * mru-cache
  * A cache with a fixed capacity
  * Backed by a combination of a hash table and doubly-linked list
  * When the maximum capacity is reached the most recently used cache
    entries are deleted.</p>

<h3>get-cached-value, (setf get-cached-value)</h3>

<p>One of the main expansion points for new cache subclasses. These place
and retrieve values from whatever backing store the cache is using</p>

<p>Returns (values results cached-at) and stores the results of executing
the underlying function.</p>

<h3>purge-cache, purge-all-caches</h3>

<p>A function that will remove expired entries from the cache, allowing
them to be garbage collected</p>

<h3>clear-cache, clear-all-caches</h3>

<p>A function that will remove all cached results from the cache.</p>

<p><code>clear-cache</code> accepts either a cache or the name of a cached function</p>

<h4>clear-cache-partial-arguments</h4>

<p>This function will go through the cached-results removing
keys that partially match the to-match list.</p>

<p>This is used to clear the cache of shared? caches, but is also useful
in other cases, where we need to clear cache for some subset of the
arguments (eg: a cached funcall might wish to clear the cache of a
specific funcalled function).</p>

<p>Matches arguments for those provided. Anything not provided is
considered function-cache:dont-care.  Anything specified as
function-cache:dont-care is not used to determine if there is a match</p>

<p>uses partial-argument-match? to determine if the key should be removed</p>

<h4>partial-argument-match?</h4>

<p>Trys to see if the cache-key matches the to-match partial
key passed in.</p>

<p>The basic implementation is to go through the cache-keys and match in
order, skipping to-match component that is function-cache:dont-care</p>

<h3>compute-cache-key, defcached-hashkey</h3>

<p>Compute-cache-key, takes a cache and a list of arguments and turns
those into a valid cache-key for the cache, by calling
defcached-hashkey recursively through the argument tree.</p>

<p>Shared cache-backings will ensure the function name is the first token
in this cache-key</p>

<h3>cacher</h3>

<p>Cacher is responsible for looking up memoized results in the cache,
checking if they are expired/missing and running the body if so,
caching and returning the result</p>

<h3>*cache-names*</h3>

<p>A list of all the special variables created by defcached.  Used to
ease clearing/purging all the caches, and for introspective purposes.</p>

<h2>Authors</h2>

<ul>
<li><a href="http://www.acceleration.net/" >Acceleration.net</a></li>
<li><a href="http://russ.unwashedmeme.com/blog" >Russ Tyndall</a></li>
<li><a href="http://the.unwashedmeme.com/blog" >Nathan Bird</a></li>
<li><a href="http://ryepup.unwashedmeme.com/blog" >Ryan Davis</a></li>
</ul>

<pre><code>;; Copyright (c) 2013 Russ Tyndall , Acceleration.net http://www.acceleration.net
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are
;; met:
;;
;;  - Redistributions of source code must retain the above copyright
;;    notice, this list of conditions and the following disclaimer.
;;
;;  - Redistributions in binary form must reproduce the above copyright
;;    notice, this list of conditions and the following disclaimer in the
;;    documentation and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;; A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
;; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
;; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
;; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</code></pre>
