<h1>Access</h1>

<p>A Common Lisp library to unify access to the most common data
structures and to allow you to operate on them as they are (ie as a
bunch of dictionaries with slightly different apis)</p>

<h2>access, accesses , (setf access), (setf accesses)</h2>

<p>These functions allow unified access to these data structures:</p>

<ul>
<li>accessor access to CLOS objects</li>
<li>slot access to CLOS objects if the key matches a slot name but not
   an accessor</li>
<li>plists</li>
<li>alists</li>
<li>hash-tables</li>
<li>arrays</li>
</ul>

<p>They also opts to produce nil as opposed to signaling errors when they
fail to access (eg (access nil &apos;anything) produces nil rather than
signaling a missing method on nil (though if &apos;anything is specialized
on nil it will call that method)). Slot unboundedness errors are not 
signaled.</p>

<p>This library will probably appeal most to new comers to the language
as everyone else will probably be happy just calling each type of
access according to its own api.</p>

<h3>accesses, (setf accesses)</h3>

<p>These can be handy for modifying deeply nested structures without lots
of intermediary bindings eg:</p>

<p>(setf (accesses ucw::<em>context</em> &lsquo;ucw::context.request
               ucw::parameters &rsquo;(&ldquo;id&rdquo; :type :alist)) 
      2043) </p>

<p>Will correctly set the &ldquo;id&rdquo; parameter of the request to 2043. 
It will not signal an error if request is <em>context</em> is unbound, nor 
any of the slots.</p>

<p>The &apos;(&ldquo;id&rdquo; :type :alist) is required because ucw expects an alist, but
access will default to plist when asked to set on a nil.</p>

<h2>do-access, do-set-access</h2>

<p>When we fail to find an reader/writer function, access will ultimately
have to be reading and writing a datastructure.  That happens in these
generic functions.  These functions also allow access extensibility to
support any conceivable map datastructure.</p>

<h3>What happens when setting through nil?</h3>

<p>Access will create a dictionary to put stuff into. The type of
dictionary will depend on the :type parameter.  </p>

<ul>
<li>:type is expected to be: cl:array, :array, cl:hash-table , :plist,
   :alist, :object, cl:standard-object, or a type that we can call
   &apos;make-instance on with no arguments.</li>
</ul>

<p>EX:</p>

<pre><code>=&gt;(setf (accesses place
         '(:a :type :alist)
         '(2 :type array)
         '(:b :type 'hash-table)) 3)
;; 3

=&gt; place

;; ((:a . #(nil nil #&lt;hash-table :b=3 &gt;)))
</code></pre>

<h3>Limitations</h3>

<ul>
<li>Accessors should share slot names for this to work best.  This is
   due to differences in &ldquo;direct&rdquo; class slots versus indirect slots
   (only direct slots have the reader value filed out).</li>
<li>While most structures use equalper to get around differnt key
   packages and strings vs symbols.  Hash-tables do not currently
   support an equalper style interface.  As such some small care needs
   to be taken.  We try to support this by looking up values by
   symbol, then by symbol-name if symbol fails to produce a result.</li>
</ul>

<h3>A word on performance</h3>

<p>This libary is meant to make writing the program easier.  It does many
runtime lookups and checks to make sure that funcations called can
support the types they are called with.  As such it should not be used
in code where performance is important. It should however allow you to
prototype more rapidly and change the backing data stores without
having to change their access (ie I can switch from a plist to an
alist and everything will continue to work)</p>

<h2>Utilities</h2>

<h3>has-slot?, has-reader?, has-writer?</h3>

<p>Given a function or symbol, see if the object has a slot named that or
a reader/writer function associated with that name</p>

<h3>class-slot-names, class-slot-readers, class-slot-writers</h3>

<p>Returns the names associated with the classes slots.  Readers and
writers returns the functions used to access and set these slots,
however these currently only support readers/writers with the same
name as the slot.</p>

<h3>call-if-applicable, call-applicable-fns</h3>

<p>Given an object and a function / funcation-name, this will call the
function passing in the object if it seems like that will work</p>

<h3>class-of-object</h3>

<p>A helper to find you the class of a given thing</p>

<pre><code>  (typecase o
      (symbol (find-class o))
      (standard-class o)
      (standard-object (class-of o)))</code></pre>

<h3>equalper</h3>

<p>A predicate to make comparing symbols in different packages easier, by
comparing them case-insensitively based on symbol-name.  In other
respects it is equalp.</p>

<h3>plist-val, rem-plist-val, set-plist-val</h3>

<p>Functions to ease access to plist values (used by access when
detecting a plist)</p>

<h2>DOT syntax</h2>

<p>DOT syntax is invoked with #D reader macro on a form or by wrapping
that form in a with-dot call</p>

<p>Many new-comers to the language long for their dot operator from other
lanugages they know.  This functionality is provided (when desired) by
enable-dot-syntax (for #D) or wrapping a block in the with-dot macro.  I wrote
these for fun and much prefer just using the access functions directly
(ie. I never actually use these syntax transformers).  That said, when
the dot syntax is enabled, symbols with a dot in them will be
transformed to the appropriate <code>accesses</code> calls.</p>

<p>EX: #Dfoo.bar.bast &rArr; (accesses foo &apos;bar &apos;bast)
  EX: (with-dot () (setf ht.key.subkey new-val)) &rArr; (setf (accesses ht &apos;key &apos;subkey) new-val)</p>

<h2>Authors</h2>

<ul>
<li><a href="http://www.acceleration.net/" >Acceleration.net</a> - <a href="http://www.acceleration.net/programming/donate-to-acceleration-net/" >Donate</a></li>
<li><a href="http://russ.unwashedmeme.com/blog" >Russ Tyndall</a></li>
<li><a href="http://the.unwashedmeme.com/blog" >Nathan Bird</a></li>
<li><a href="http://ryepup.unwashedmeme.com/blog" >Ryan Davis</a></li>
</ul>

<pre><code>;; Copyright (c) 2011 Russ Tyndall , Acceleration.net http://www.acceleration.net
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are
;; met:
;;
;;  - Redistributions of source code must retain the above copyright
;;    notice, this list of conditions and the following disclaimer.
;;
;;  - Redistributions in binary form must reproduce the above copyright
;;    notice, this list of conditions and the following disclaimer in the
;;    documentation and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;; A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
;; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
;; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
;; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</code></pre>
