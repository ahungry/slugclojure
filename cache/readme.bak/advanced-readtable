<h1>advanced-readtable</h1>

<p>Features
- per-package aliases for packages
- per-package shortcuts for package hierarchies
- extendable find-package and find-symbol
- local use package in form package:(here form where package used)
- local intern package like in SBCL: package::(symbol1 symbol2) will intern
                                     package::symbol1 and package::symbol2</p>

<h2>To start</h2>

<p>Either use named-readtables and write</p>

<pre><code>(in-readtable :advanced)
</code></pre>

<p>or simply add to advanced-readtable to current readtable</p>

<pre><code>(advanced-readtable:!)
</code></pre>

<p>If you want also to substitute cl:defpackage, cl:in-package,
cl:find-package and cl:find-symbol by there adbanced versions,
use (advanced-readtable:!!) or (in-readtable :advanced) and
(advanced-readtable:activate-cl-substitutes).</p>

<h2>SLIME integration</h2>

<p>Append contents of init.el to the end of your ~/.emacs file.</p>

<p>Then, when you start slime, advanced-readtable will be loaded and used by slime.
So you will have all completions for hierarchy packages, local-nicknames, 
aliases, &hellip;</p>

<p>Note: in REPL you will have advanced-readtable instead of the standard 
readtable.</p>

<h2>Hierarchy packages</h2>

<p>Advanced-readtable has fully functional built-in support of hierarchy-packages.
.name means &ldquo;subpackage name in current package&rdquo;, ..name &ndash; &ldquo;subpackage name in above package&rdquo;,
&hellip;name &ndash; &ldquo;subpackage in two-level-up package&rdquo; and so on.
In in-package you may use .. for above package, &hellip; for two level up, and so on.
Verbose documentation one may see at <a href="http://www.franz.com/support/documentation/9.0/doc/packages.htm#relative-2" >allegro CL</a>.</p>

<pre><code>CL-USER&gt; (defpackage .test (:use cl)))
#&lt;PACKAGE &quot;COMMON-LISP-USER.TEST&quot;&gt;
CL-USER&gt; (in-package .test)
TEST&gt; (in-package ..)
CL-USER&gt; (defpackage .test.a (:use cl))
#&lt;PACKAGE &quot;COMMON-LISP-USER.TEST.A&quot;&gt;
CL-USER&gt; (in-package .test.a)
A&gt; '...::car
CAR
A&gt; (eq '...::car 'cl:car)
T
A&gt; (in-package ...test)
TEST&gt; (in-package ..)
CL-USER&gt;
</code></pre>

<p>You may use local-nicknames in defpackage (syntax taken from <a href="https://github.com/nikodemus/SBCL/commit/3c11847d1e12db89b24a7887b18a137c45ed4661" >SBCL</a>)</p>

<pre><code>CL-USER&gt; (defpackage :foo (:use :cl) (:local-nicknames (:it :cl)))
CL-USER&gt; (in-package :foo)
FOO&gt; (it:car '(1 2 3))
1
</code></pre>

<h1>API</h1>

<h2><em>push-import-prefix</em> &ndash; enables import prefix on package name</h2>

<p>For example, you have packages com.clearly-useful.iterator-protocol, com.clearly-useful.reducers, &hellip;
You may use them as</p>

<pre><code>(push-import-prefix :com.clearly-useful)
(iterator-protocol:do-iterator ...)
(reducers:r/map #'1+ data)
</code></pre>

<p>and so on.
Package prefix is enabled per package so it is safe to use it in your package.</p>

<p>If there is package, which name coincides with shortcut, package name has priority.</p>

<p>So, if you make</p>

<pre><code>(defpackage :reducers ...)
</code></pre>

<p>after that reducers:&hellip; will refer to new package, not com.clearly-useful.reducers.</p>

<h2><em>push-local-nickname</em> &ndash; enables nickname for package in current package</h2>

<p>Enables package nickname in CURRENT-PACKAGE.
For example, you found COM.INFORMATIMAGO.COMMON-LISP.CESARUM.LIST package and want to use
it. But don&apos;t want to USE-PACKAGE them, because some exported symbols from it are clashing 
with yours.</p>

<p>You may do it right:</p>

<pre><code>(push-local-nickname :com.informatimago.common-lisp.cesarum.list :ilist)
(ilist:circular-length l)
</code></pre>

<p>Local-nicknames are local, so you may use it freely.</p>

<p>If package A wants package LIB version 1, and package B wants package LIB version 2, one can simply 
rename LIB version 1 to LIB1 and LIB version 2 to LIB2 and make</p>

<pre><code>(push-local-nickname :lib1 :lib :a)
(push-local-nickname :lib2 :lib :b)
</code></pre>

<p>This command also adds local subpackage alias. In the previous example a.lib 
and b.lib will be aliases to lib1 and lib2. If there is a real package with 
such name, alias will be shadowed, so don&apos;t worry too much about it.</p>

<h2><em>push-local-package</em> &ndash; sets local-package for a symbol</h2>

<p>Many macroses use there own clauses. 
For example, ITERATE uses FOR, COLLECT and so on. 
If you don&apos;t want to USE-PACKAGE iterate, this function will help.</p>

<pre><code>(push-local-package 'iter:iter :iterate)
(iter:iter (for i from 1 to 10) (collect i))
</code></pre>

<p>Caution: this function enables package substitution in all cases, 
where SYMBOL is the car of a list.
For example, this will be error:</p>

<pre><code>(let (iter:iter for) (list iter:iter for))
</code></pre>

<p>, because first for is in ITERATE package, but second &ndash; is not.</p>

<p>Be careful: this change is not local to your package.</p>

<h2><em>set-macro-symbol</em> symbol func &ndash; sets FUNC to process the SYMBOL.</h2>

<p>FUNC will get stream of reader and the symbol (see set-macro-character).</p>

<p>To prevent symbol from processing (for example in set-macro-symbol construction) you should enclose it in bars.</p>

<p>This construction will set &apos;foo as an alias to &apos;long-package-name:long-name:</p>

<pre><code>(set-macro-symbol '|FOO|
  (lambda (stream symbol)
     (declare (ignore stream symbol))
        'long-package-name:long-name))
</code></pre>

<p>Another way to prevent symbol processing is setting <code>advanced-readtable:*enable-symbol-readmacro*</code> to nil. 
Remember, that symbol processing is done during reading the file, so, if you need to temporarily disable
<code>*enable-symbol-readmacro*</code>, then enclose it in #.</p>

<p>Now you may make something like </p>

<pre><code>html:[body [table (as-html sql:[select * from t1])]]
</code></pre>

<p>html:[ and sql:[ will have different handlers and you may mix them in
one expression.</p>

<p>Moreover, you may alias variables from other packages and set them through 
alias. But be careful: this change is not local to your package. If you write qualified name
of the symbol, you should enclose package-name in bars:</p>

<pre><code>(set-macro-symbol '|OTHER-PACKAGE|:foo
  (lambda (stream symbol)
     (declare (ignore stream symbol))
        'long-package-name:long-name))
</code></pre>

<h2><em>get-macro-symbol</em> - syntax is like get-macro-character,</h2>

<p>Returns function, assigned by set-macro-symbol</p>

<h2>Low-level API</h2>

<p>There are five lists:
-  <code>*package-finders*</code> &ndash; global for find-package
-  <code>*symbol-finders*</code> &ndash; global for find-symbol
-  (package-finders package) &ndash; per-package for find-package
-  (symbol-finders package) &ndash; per-package for find-symbol
-  (extra-finders symbol) &ndash; per-symbol for (symbol &hellip;.) package substitution</p>

<p>They are all alists. Key denotes handler and should be uniq for the list.
Value should have form (lambda (name package) &hellip;) and return symbol for
symbol-finders and extra-finders and return pacakge for package-finders.</p>

<p>You may freely change them to develop your own symbol or package schemes
(for example, hierarchy-packages, conduits and so on).</p>

<h2>Middle-level API</h2>

<p>To simplify adding new handlers with keys there is macro <em>set-handler</em></p>

<pre><code>(set-handler (package-finders pack) '(:my handler1) #'handler-func)
</code></pre>

<p>will set handler for package pack, if there are no hanler with key 
(:my handler1). So you may set it in your file and not be afraid, that it
will duplicate on reloading.</p>

<h2>Restrictions</h2>

<p>You must only ASCII characters for first letter of every part of package name 
and for first letter of symbols, that you want to use in set-macro-symbol</p>

<p>If you really need other characters you may set them by calling</p>

<pre><code>(set-macro-character c #'advanced-readtable:read-token-with-colons t)
</code></pre>

<p>for every your character.</p>

<p>If you need to temporary disable macro-characted substitution, you may set 
<code>advanced-readtable:*enable-symbol-readmacro*</code> to nil. It could be useful, if you
describe a lot of symbols and don&apos;t want to enclose every of them in || (and upcase, of course).</p>
