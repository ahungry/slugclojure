<h1><a id="sec-1" name="sec-1"></a>Introduction</h1>

<p><strong>NOTE</strong> - Because of some mishap with QuickLisp, June 2013 QuickLisp distribution
pulled the <strong>master</strong> branch of Log4CL instead of <strong>stable</strong> branch as intended.</p>

<p>Very few incompatibilities been reported, and it makes no sense to downgrade
version that been already available in QuickLisp, therefore QuickLisp will
continue to pull the <strong>master</strong> branch from now on.</p>

<p>The major difference of Log4CL 1.1.x version from 1.0.x is the Emacs/Slime integration
module, called <strong>Log4Slime</strong>. This document is written with assumption that you will
have Log4Slime loaded and enabled in Emacs.</p>

<h2><a id="sec-1-1" name="sec-1-1"></a>Installation</h2>

<p>Log4CL is available from QuickLisp. To load it use <code>(ql:quickload :log4cl)</code>
command from REPL. Log4Slime is available in QuickLisp since June 2013.</p>

<h2><a id="sec-1-2" name="sec-1-2"></a>Enabling Log4Slime</h2>

<pre><code><span class="code"><span class="paren1">(<span class="code">ql:quickload <span class="keyword">:log4slime</span></span>)</span>
<span class="paren1">(<span class="code">log4slime:install</span>)</span></span></code></pre>

<p>You should get a message like this:</p>

<pre><code>Wrote ~/quicklisp/log4slime-setup.el

Add the following two statements to your ~/.emacs file
------------------------------------------------------
(load "~/quicklisp/log4slime-setup.el")
(global-log4slime-mode 1)
------------------------------------------------------</code></pre>

<p>Follow the above instructions. The most likely point of failure here
may be <code>log4slime.el</code> trying to poke the Lisp side to see if log4slime
is loaded, and that for some reason it fails.</p>

<p>If it fails, there should be a message in <code>*Messages*</code> buffer, that looks
like this: <code>Unable to load log4slime lisp support: &lt;lisp side condition&gt;</code></p>

<p>In case you did get the above message and you think you fixed the
cause, you can make log4slime try again, by turning <code>M-x
global-log4slime-mode</code> off/on a few times</p>

<p>You can verify if log4slime is enabled, by looking for the Log4CL menu
on top menubar in REPL and Lisp mode buffers, or by submitting a log
statement from REPL and seeing output colorized.</p>

<p><a id="The-Basics" name="The-Basics"></a></p>

<h1><a id="sec-2" name="sec-2"></a>Hello world</h1>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">progn</span></i>
  <span class="paren2">(<span class="code">log:info <span class="string">"I just ate a ~5f, feeling tired"</span> pi</span>)</span> 
  <span class="paren2">(<span class="code">when <span class="paren3">(<span class="code">log:debug</span>)</span>
    <span class="paren3">(<span class="code">dotimes <span class="paren4">(<span class="code">sheep 3</span>)</span>
      <span class="paren4">(<span class="code">log:debug sheep <span class="string">"zzz"</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">log:warn <span class="string">"doh fell asleep for"</span> <span class="paren3">(<span class="code">random 10</span>)</span> <span class="string">"minutes"</span></span>)</span></span>)</span></span></code></pre>

<p>Should produce the following output
<img src="./images/screenshot-12.png" alt="nil" /></p>

<p>You can notice several things right away.</p>

<ul>
<li><p>You can intermix strings and expressions, and expressions will be
printed as their un-evaluated form as well as the their value;
using a constant <code>FORMAT</code> control string as first argument
automatically switches to <code>FORMAT</code> mode.</p></li>
<li><p>Log statements without arguments, turn into conditional expression
that tells you if logging is enabled or not</p></li>
<li><p>The log output contains some headers in addition to the raw log
message, such as the <a href="#level" >log level</a> that message was submitted with,
the time of the message as well as what looks like the name of the
current package, and (If you have Log4Slime loaded and turned on),
these headers use different faces from actual log message.</p></li>
</ul>

<h2><a id="sec-2-1" name="sec-2-1"></a>Changing the log level</h2>

<p>You can change the <a href="#level" >log level</a> with by doing
<code>(log:config :debug)</code> from <code>REPL</code>. Alternatively, with
Log4Slime enabled in <code>REPL</code> buffer, you can right-click on the
<strong>cl-user</strong> part and change the log level from a popup menu.</p>

<p><img src="./images/screenshot-15.png" alt="nil" /></p>

<p>There is a slight difference between doing it using above two
methods, with <code>log:config</code> command, the level is changed for the
<code>ROOT</code> <a href="#category" >category</a>, but right clicking on the package
name, changes the <a href="#level" >log level</a> only for that package.</p>

<p>To change the <code>ROOT</code> <a href="#category" >category</a> from Emacs, you can use Log4CL
dropdown submenu, or Emacs command <code>log4slime-level-selection</code> which
is bound to <code>C-c C-g</code> by default.</p>

<p>After pressing <code>C-c C-g</code> which invokes the <code>log4slime-level-selection</code> command
you get the following window.</p>

<p><img src="./images/screenshot-11.png" alt="nil" /></p>

<p>Pressing &ldquo;p&rdquo; to select the package category shows effective log level
and allows you to change like so</p>

<p><img src="./images/screenshot-10.png" alt="nil" /></p>

<p>This concludes the very basic introduction, if you were confused by
what various terms such as &ldquo;<a href="#category" >category</a>&rdquo; mean, click on the hyperlink
to read more about Log4CL concepts.</p>

<p>Or you can skip the theory and just continue to learn by example.</p>

<p><a id="naming" name="naming"></a></p>

<h1><a id="sec-3" name="sec-3"></a>Automatic category naming</h1>

<p>Try putting the from the previous section into a <code>DEFUN</code> instead of a
<code>PROGN</code> form like so:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> hello <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">log:info <span class="string">"I just ate a ~5f, feeling tired"</span> pi</span>)</span> 
  <span class="paren2">(<span class="code">when <span class="paren3">(<span class="code">log:debug</span>)</span>
    <span class="paren3">(<span class="code">dotimes <span class="paren4">(<span class="code">sheep 3</span>)</span>
      <span class="paren4">(<span class="code">log:debug sheep <span class="string">"zzz"</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">log:warn <span class="string">"doh fell asleep for"</span> <span class="paren3">(<span class="code">random 10</span>)</span> <span class="string">"minutes"</span></span>)</span></span>)</span></span></code></pre>

<p>If you run it now, the output under both <strong>SBCL</strong> and <strong>CCL</strong> should
look like this.</p>

<p><img src="./images/screenshot-16.png" alt="nil" /></p>

<p>Right click on the blue function name, allows you to change the log
level for that specific function.</p>

<p>That is because Log4CL logging macros, automatically determine the
<a href="#category" >category</a> for logging, based on the context where log statement
appears. In above example the function was defined in the package
CL-USER and function name was HELLO, so the target category of any
logging inside the function, was automatically <code>CL-USER.HELLO</code></p>

<p>It starts with the package, then function. You can try
putting one of the log statements inside of a <code>LABELS</code> or <code>FLET</code>
forms, to see what happens.</p>

<p>Also note the farthest to the right in the logging <a href="#category" >category</a>
name, the more specific. The level for &ldquo;hello&rdquo; overrides that for
&ldquo;cl-user&rdquo;, which in turn overrides that of the root category.</p>

<h2><a id="sec-3-1" name="sec-3-1"></a>Naming in source files</h2>

<p>For the next few examples, it is recommended that you load the
examples come together with Log4CL, by doing <code>(ql:quickload :log4cl-examples)</code></p>

<p>It should produce the following output:</p>

<p><img src="./images/screenshot-17.png" alt="nil" /></p>

<p>One thing you should notice, is that source file where function is
defined now appears as part of the log message too. Go to the source
of &ldquo;greetings&rdquo;. Before you try to use Slime&apos;s famous <code>M-.</code> shortcut, try
clicking on blue &ldquo;greetings&rdquo; word with a left mouse button.</p>

<p>If everything went better then expected, it should land you at the first
log statement of the <code>(defun greetings ())</code>. Cool eh?</p>

<h2><a id="sec-3-2" name="sec-3-2"></a>Naming in CLOS methods</h2>

<p>Quickly browse through <code>naming-examples.lisp</code>. There are a few methods defined,
including <code>:after/:around</code> methods, as well as some with <code>EQL</code> specializers. </p>

<p>Run a few of them from REPL, like so:</p>

<p><img src="./images/screenshot-18.png" alt="nil" /></p>

<p>Log statements inside of methods, are using the <a href="#category" >category</a> name of the 
generic function, extended with qualifier, and all non-T specializers.</p>

<p>Try going to the source of the above methods by clicking on them. It should land
in the right method, without showing Slime&apos;s XREF window.</p>

<p>Note how by changing the level of the <code>foobar</code> you control all the
methods, but can override them based on their specializers. Try
setting <code>:after</code> category to different levels, to control all
the <code>:after</code> methods together.</p>

<p>In addition to playing with methods, try <code>(setf (test.package.one:greetings) &quot;Hey&quot;)</code> too.</p>

<h2><a id="sec-3-3" name="sec-3-3"></a>Context sensitivity</h2>

<p>As you browse through source, and are inside of one of the methods, 
check out the Log4CL dropdown menu. Note that &ldquo;Defun&rdquo; submenu changes
for each method.</p>

<p><img src="./images/screenshot-19.png" alt="nil" /></p>

<h2><a id="sec-3-4" name="sec-3-4"></a>Keyboard level selection</h2>

<p>Also try <code>C-c C-g</code> shortcut in the same place. You can configure it
not to show the selection window at all, by customizing the
<code>log4slime-level-selection-single-key</code> Emacs variable.</p>

<p>After pressing <code>C-c C-g</code> while inside of the method
<img src="./images/screenshot-20.png" alt="nil" /></p>

<p>You can change keys for the selecting various levels by doing <code>M-x
   customize-group RET log4slime RET</code></p>

<p>Note that keyboard selection ignores the Control key so <code>C-c C-g p
   u</code> is same as <code>C-c C-g C-p C-u</code></p>

<h2><a id="sec-3-5" name="sec-3-5"></a>Resetting the mess</h2>

<p>If you had forgotten which levels you set for what, and just want
to see which levels are set where.</p>

<p>You can display current logging configuration by doing
<code>(log:config</code>) without any arguments, it willdisplay a tree</p>

<p><img src="./images/screenshot-23.png" alt="nil" /></p>

<p>If you have had set a lot of custom levels, and now need to get rid
of them, &ldquo;Reset Children&rdquo; menu item will nukes the log level from
everything underneath the parent. Doing &ldquo;Reset Children&rdquo; on the
ROOT category, gets rid of every other log level that was set
anywhere. Keyboard equivalent is <code>C-c C-g r</code></p>

<p><img src="./images/screenshot-22.png" alt="nil" /></p>

<h2><a id="sec-3-6" name="sec-3-6"></a>Logging configurations</h2>

<p>After setting the log levels of a few methods, try doing <code>(log:save :foo)</code> 
then messing around.. You can restore the named configuration with 
<code>(log:restore :foo)</code>. Configurations are saved in a file in the
home directory, so they survive image restarts</p>

<p>See the <a href="#needle" >Finding needle in a haystack</a> section.</p>

<h1><a id="sec-4" name="sec-4"></a>The magic of (LOG:CONFIG)</h1>

<p>Section To be written, for now simply see <a href="http://github.com/7max/log4cl/blob/master/src/configurator.lisp" >docstring for LOG:CONFIG</a></p>

<p>Read the docstring and play with options, below are a few examples:</p>

<p><img src="./images/screenshot-25.png" alt="nil" /></p>

<h1><a id="sec-5" name="sec-5"></a>Pattern Layout</h1>

<p>Section to be written, for now see docstring for
<a href="http://github.com/7max/log4cl/blob/master/src/pattern-layout.lisp" >docstring for PATTERN-LAYOUT</a></p>

<h1><a id="sec-6" name="sec-6"></a>Common Practices</h1>

<p>Some common recipes.</p>

<h2><a id="sec-6-1" name="sec-6-1"></a>Log levels for production</h2>

<p>Generally log levels <code>INFO</code> and below, are used in normal
operations of software, while levels higher then <code>INFO</code> are used
by programmers.</p>

<ul>
<li><p><code>FATAL</code> is used for un-recoverable errors, that
require restart of an application or major component, the <code>FATAL</code>
messages are to inform the user that something had died in a 
way that should not normally happen.</p></li>
<li><p><code>ERROR</code> is for serious but generally recoverable errors, that occur
doing a normal operation of software. File not found, or such.</p></li>
<li><p><code>WARN</code> is for &ldquo;suspicious&rdquo; things, or to inform the user that
some automatic corrective action had failed. Maximum number of retries reached
or such.</p></li>
<li><p><code>INFO</code> is for informing on major steps that software is performing, and
is usually thought of the maximum log level used in normal operations, its
&ldquo;Say what you are doing but don&apos;t flood&rdquo; type of messages.</p></li>
</ul>

<p>By default Log4CL is configured with root category having <code>INFO</code>
log level.</p>

<p><a id="development" name="development"></a></p>

<h2><a id="sec-6-2" name="sec-6-2"></a>Log levels for development</h2>

<p><code>DEBUG</code> is for for informing about detailed steps taken by operations
and printing intermediate values. </p>

<p><code>TRACE</code> is for very detailed debugging, like printing variables inside
loops and such.</p>

<p><code>DEBU1..DEBU9</code> log levels are numerically around the <code>TRACE</code> and can be used
if you need more granularity. One possibility is that <code>(log:expr)</code> macro, can
be configured via <code>LOG:PACKAGE-OPTIONS</code> mechanism, to use different
log level then <code>DEBUG</code> and can set to use one of the extra levels.</p>

<p><code>OFF</code> log level is very important counter-part for <code>DEBUG</code> and
<code>TRACE</code>.  Its used for &ldquo;narrowing things down in reverse&rdquo;, which is
described in the next section</p>

<p><a id="needle" name="needle"></a></p>

<h2><a id="sec-6-3" name="sec-6-3"></a>Finding needle in a haystack</h2>

<p>Programmers often need to concentrate on a specific area of their
software.  With traditional non-hierarchical logging system,
having a lot of debug sprinkled around the code, flood the
programmers with a lot of information they don&apos;t need, and makes
it hard to find the messages relevant to the problem being
debugged.</p>

<p>Because Log4CL is hierarchical, its easy to narrow down the
logging, to focus on exactly the right area, by using the
following process.</p>

<ol>
<li><p>Turn <code>DEBUG</code> on for the root category, or entire package and
then run your code through the functionality that you are
focusing on. REPL will fill with a lot of debugging output.</p></li>
<li><p>Right-click on each message that is not related to a problem,
and turn the corresponding category <code>OFF</code>. You can how go wide
or narrow, turn off entire packages or source files, or by
individual methods, functions or local functions. If you went
too far, use <strong>Reset children</strong> command on the parent category.</p>

<p>If you use CLOS, use the category hierarchy to your advantage,
if for example you think problem relates to before or after
method, you can can control logging for all :AFTER methods of
generic function by clicking :after category in 
<code>(&lt;gf name&gt; :after &lt;specializer&gt; ...)</code></p></li>
<li><p>Once you narrowed down the logging to your liking, you can
quickly save that configuration of log levels with
<code>(LOG:SAVE)</code>, and later (may be in a different image, or even
different machine) restore it with <code>(LOG:RESTORE)</code>, and you can
give these saved configuration names, such as
<code>(LOG:SAVE :bug-123)</code></p></li>
</ol>

<h1><a id="sec-7" name="sec-7"></a>Glossary</h1>

<p>Very small glossary of Log4CL concepts</p>

<p><a id="logger" name="logger"></a><a id="category" name="category"></a></p>

<h2><a id="sec-7-1" name="sec-7-1"></a>Loggers and categories</h2>

<p>Loggers are named singleton objects that form a hierarchy, and are
sources of log messages, or more correctly entry points where log
message enter the logging system.  Each call to a logging macro like
<code>(log:debug ...)</code> operates on a specific logger object 
(See also <a href="#naming" >naming</a> section).</p>

<p>Logger&apos;s unique name is called &ldquo;logger&apos;s category&rdquo;, or &ldquo;category
name&rdquo;. Loggers form a hierarchy, based on their category names,
where child loggers have their category name prefixed by that of the
parent, followed by a dot. So if we have loggers <strong>A</strong>, <strong>A.B</strong>, <strong>A.B.C</strong>
and <strong>A.B.D</strong> then logger <strong>A</strong> is parent of <strong>A.B</strong>, which has two
children <strong>A.B.C</strong> and <strong>A.B.D</strong> - as shown on below diagram.  (Note:
ROOT logger category name is empty string)</p>

<pre><code>ROOT---A---A.B---A.B.C
             |
             \---A.B.D</code></pre>

<p>Because loggers are singletons, logger category name is usually shortened to just
<em>CATEGORY</em> and is used inter-changeably with the word <em>LOGGER</em>; the convention
is that thing is &ldquo;a logger&rdquo; when talking about actual Lisp object, and
&ldquo;category&rdquo; otherwise.</p>

<p>Each logger can have a <a href="#level" >log level</a> threshold, or if its
does not have one, it inherits one from its parent. To ensure that
for any logger, an effective log level can be determined, the ROOT
logger always have a level.</p>

<p>Loggers will only pass through messages, if logger&apos;s threshold level
is equal or greater verbosity, then log message. For example if in
above example logger A is configured with <em>info</em> log level, then
<code>(log:warn ...)</code> and <code>(log:info)</code> messages will be passed through,
but <code>(log:debug)</code> messages would not.</p>

<p><a id="appender" name="appender"></a></p>

<h2><a id="sec-7-2" name="sec-7-2"></a>Appenders</h2>

<p>Appenders process log messages by writing them to files, or
displaying them on the screen. Appenders attach to a specific
logger, and each logger can have many appenders attached.</p>

<p>When a log message passes through a logger that has appenders, they
are all called in turn to do appender specific processing, be it
writing log message to a file, or a terminal. After all of logger&apos;s
appenders had processed the message, its passed on to the parent
logger.</p>

<p>So log messages inheritance flows in reverse order from the log
level one, tricking up from child loggers towards root, with below
exception.</p>

<p>Each logger has a property called <em>additivity</em>, which is <code>T</code> by
default, which controls the above process. When additivity is
<code>NIL</code>, logger is called non-additive and any messages that reach
it, will not be passed to the parents.</p>

<p>Usually only root logger, or non non-additive loggers will have any
appenders attached to them.</p>

<p><a id="layout" name="layout"></a></p>

<h2><a id="sec-7-3" name="sec-7-3"></a>Layouts</h2>

<p>When appender decide they want to process the log message, they format
the log message by means of a layout. Layout is a separate object, that attaches
to each appender, and is responsible for the textual formatting of the message.</p>

<p>So while appender provides and manages any serialization for the
stream to write to, the layout is actually formatting the log
message into that stream.</p>

<p>Log4CL provides two layouts, SIMPLE-LAYOUT which is well, simple,
and a very configurable PATTERN-LAYOUT, which specifies the formatting
of log messages by mean of printf/format like control string.</p>

<p>Easiest way to use the pattern layout, is by using <a href="http://github.com/7max/log4cl/blob/master/src/configurator.lisp" >LOG:CONFIG</a>
command to select between several predefined formats.</p>

<p>Or you can look for list of all supported format documentation for
the <a href="http://github.com/7max/log4cl/blob/master/src/pattern-layout.lisp" >PATTERN-LAYOUT</a> class. Please note that if you are
drafting your own format, that Log4SLime fontification relies on
regular expressions and the log messages being in a certain
order. If your layout is not a minor modification of an built-in
one, the Log4Slime fontification may stop working.  You can of
course adjust the regular expressions used by Log4Slime to match
your own custom layout to compensate.</p>

<p><a id="level" name="level"></a><a id="log-level" name="log-level"></a></p>

<h2><a id="sec-7-4" name="sec-7-4"></a>Log Levels</h2>

<p>In Log4CL log levels are numeric constants, in order of increased
verbosity: </p>

<ul>
<li><p>Turn off logging <code>0=OFF</code></p></li>
<li><p>Standard log levels <code>1=FATAL</code>, <code>2=ERROR</code>, <code>3=WARN</code>, <code>4=INFO</code>, <code>5=DEBUG</code></p></li>
<li><p>Extra debug levels <code>6..9</code> named <code>DEBU1</code> through <code>DEBU4</code></p></li>
<li><p>Standard log level <code>10=TRACE</code></p></li>
<li><p>Extra debug level <code>11..15</code> named <code>DEBU5</code> through <code>DEBU9</code></p></li>
</ul>

<p><a id="effective" name="effective"></a></p>

<h2><a id="sec-7-5" name="sec-7-5"></a>Effective log level</h2>

<p>Effective log level of the logger <strong>X</strong> is determined as follows.</p>

<ol>
<li><p>If logger has level threshold set, then this level is the effective log level.</p></li>
<li><p>If logger is not first child of a parent, whose category is same as the package 
name logger was instantiated from, the effective log level of <strong>X</strong> is the effective
log level of its parent logger.</p></li>
<li><p>If logger is first child of a parent <strong>P</strong> named same as package,
and there exists a sibling logger <strong>S</strong>, with the last part of
category name equal to that of a source file logger <strong>X</strong> was
instantiated from, and <strong>S</strong> has a level threshold set, that level
is effective level of logger <strong>X</strong></p></li>
<li><p>Otherwise effective level of logger <strong>X</strong> is effective level of its parent.</p></li>
</ol>

<p>ROOT logger always has a level threshold set, so above steps always
result in a valid log level.</p>

<p>Effective log level is returned by the function <code>(log4cl:effective-log-level LOGGER)</code> </p>

<h1><a id="sec-8" name="sec-8"></a>FAQ</h1>

<h2><a id="sec-8-1" name="sec-8-1"></a>I don&apos;t see log messages from other threads.</h2>

<p>The <code>*TERMINAL-IO*</code> value bound in the other threads is probably different and points<br/>
to other place (likely <code>*inferior-lisp*</code> buffer under Slime)</p>

<ol>
<li><p><code>(log:config :sane2)</code> will copy messages from other threads to <code>REPL</code>
while continuing output to thread specific <code>*TERMINAL-IO*</code> (<code>REPL</code>
thread will still only log to <code>REPL</code>)</p></li>
<li><p><code>(log:config :sane :this-console)</code> will redirect all logging to current console
regardless of thread local values of <code>*TERMINAL-IO*</code></p></li>
</ol>

<h2><a id="sec-8-2" name="sec-8-2"></a>Why Log4CL starts its own thread, and how I get rid of it</h2>

<p>Its a flusher thread to flush the appenders, it increases
performance greatly when there is a lot of logging.oe</p>

<p>You can stop it by calling <code>(log4cl:stop-hierarchy-watcher-thread)</code></p>

<p>On SBCL Log4CL uses <code>*EXIT-HOOKS*</code> and <code>*SAVE-HOOKS*</code> to
automatically flush all appenders on exit, so that last second of
logging is not lost, and to terminate the watcher thread when
saving image, which can&apos;t be done with multiple threads running.</p>

<h2><a id="sec-8-3" name="sec-8-3"></a>I&apos;d like just the log messages, and not all the extra stuff</h2>

<p>Use pattern layout with just %m%n format (message + newline)</p>

<h2><a id="sec-8-4" name="sec-8-4"></a>How do I log into a file</h2>

<p><code>(log:config :daily &quot;file.txt&quot;)</code> which will be backed up each day to
<code>file.txt.YYYYMMDD</code></p>

<h3><a id="sec-8-4-1" name="sec-8-4-1"></a>I want both log file and backup log file to have YYYYMMDD prefix or roll once per week</h3>

<p><code>(log:config :daily &quot;file.txt.%Y%m%d&quot;)</code> file will roll when %Y%m%d expansion
changes.</p>

<h3><a id="sec-8-4-2" name="sec-8-4-2"></a>What about just one plain file, without rolling</h3>

<p><code>(log:config :daily &quot;file.txt&quot; :backup nil)</code></p>
