<h1>BIT-SMASHER</h1>

<p><a href="https://gitter.im/thephoeron/bit-smasher?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge" ><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/thephoeron/bit-smasher" /></a></p>

<p><a href="https://travis-ci.org/thephoeron/bit-smasher" ><img src="https://travis-ci.org/thephoeron/bit-smasher.svg?branch=master" alt="Build Status" /></a>
<a href="https://coveralls.io/r/thephoeron/bit-smasher?branch=master" ><img src="https://coveralls.io/repos/thephoeron/bit-smasher/badge.svg?branch=master" alt="Coverage Status" /></a>
<a href="https://quicklisp.org/" ><img src="https://img.shields.io/badge/quicklisp-available-brightgreen.svg" alt="Available in Quicklisp" /></a>
<a href="./LICENSE" ><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="MIT License" /></a></p>

<p>Common Lisp library for handling bit vectors, bit vector arithmetic, and type conversions.</p>

<p>Available in Quicklisp as of July 2014 release.</p>

<h3>Supported Platforms</h3>

<p>BIT-SMASHER is known to compile and pass all tests with 100% code coverage on the latest 64-bit versions of the following Lisp implementations:</p>

<ul>
<li>SBCL</li>
<li>Clozure CL</li>
<li>CLISP</li>
<li>ECL</li>
<li>ABCL</li>
<li>Allegro CL</li>
</ul>

<p>It <em>does not build</em> on:
- CMUCL</p>

<p>It <em>has not been tested</em> on:
- LispWorks
- Clasp
- or other available Common Lisp implementations</p>

<h3>Usage Notes and Limitations</h3>

<p>This library was designed to complement the set of functions included in the Common Lisp specification for handling bit-vectors, by adding relevant lookup, conversion, arithmetic, measurement, and predicate functions.  For documentation and tutorials on the bit-vector functions included in the Common Lisp standard, please refer to:</p>

<ul>
<li>Common Lisp HyperSpec:

<ul>
<li><a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_sb.htm" >accessor BIT, SBIT</a></li>
<li><a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm" >function BIT-AND, etc&hellip;</a></li>
<li><a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_vec.htm" >function BIT-VECTOR-P</a></li>
</ul></li>
<li>Successful Lisp: <a href="http://psg.com/~dlamkins/sl/chapter18.html" >Chapter 18</a></li>
</ul>

<p>BIT-SMASHER only handles the set of non-negative integers.  As such, arithmetic on bit-vectors may not always produce the results you expect&mdash;return values of all arithmetic functions are given as the absolute ceiling value in bit-vector. Manual conversion of negative integers, floats, fractions, or complex numbers will trigger an error.</p>

<h3>Examples</h3>

<p>The conversion functions allow you to convert universally between bit-vectors, octet-vectors, hexadecimal strings, and non-negative integers.</p>

<pre><code><span class="code"><span class="comment">; universal type-casting style functions
</span><span class="paren1">(<span class="code">bits&lt;- <span class="string">"F0"</span></span>)</span> =&gt; #*11110000
<span class="paren1">(<span class="code">bits&lt;- 240</span>)</span> =&gt; #*11110000
<span class="paren1">(<span class="code">int&lt;- #*11110000</span>)</span> =&gt; 240

<span class="comment">; manual conversions without type-checking
</span><span class="paren1">(<span class="code">hex-&gt;bits <span class="string">"F0"</span></span>)</span> =&gt; #*11110000
<span class="paren1">(<span class="code">int-&gt;bits 10</span>)</span> =&gt; #*00001010
<span class="paren1">(<span class="code">octets-&gt;bits <span class="paren2">(<span class="code">int-&gt;octets 244</span>)</span></span>)</span> =&gt; #*11110100
<span class="comment">; etc., etc...</span></span></code></pre>

<p>Bit-vectors are returned zero-padded to the next full byte.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">bits&lt;- 255</span>)</span> =&gt; #*11111111
<span class="paren1">(<span class="code">bits&lt;- 256</span>)</span> =&gt; #*0000000100000000</span></code></pre>

<p>Arithmetic on bit-vectors can be achieved through the functions <code>bit-sum</code>, <code>bit-difference</code>, <code>bit-product</code>, <code>bit-quotient</code>, <code>bit-floor</code>, <code>bit-ceiling</code>, <code>lshift</code>, and <code>rshift</code>.  There are also the shorthand macros, <code>bit+</code>, <code>bit-</code>, <code>bit*</code>, <code>bit/</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code>.  As stated above, the bit-vector arithmetic functions return the absolute ceiling value of the operation.  So,</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">bit- #*0000 #*0010</span>)</span> =&gt; #*00000010 <span class="comment">; +2, not -2</span></span></code></pre>

<p>The measurement functions <code>wide-bit-length</code> and <code>min-bit-length</code> tell you the maximum and minimum number of bits needed to store a value, respectively.  They operate on bit-vectors, octet-vectors, hexadecimal strings, and non-negative integers.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">wide-bit-length 256</span>)</span> =&gt; 16
<span class="paren1">(<span class="code">min-bit-length 256</span>)</span> =&gt; 9</span></code></pre>

<p>There is also the measurement function <code>byte-length</code> that returns the total number of bytes required to store an integer, bit-vector, or hexadecimal value; or the actual length of byte vector or simple byte array.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">byte-length <span class="string">"A0FF"</span></span>)</span> =&gt; 2
<span class="paren1">(<span class="code">byte-length 65536</span>)</span> =&gt; 3</span></code></pre>

<p>In addition to the built-in CL predicate function, <code>bit-vector-p</code>, BIT-SMASHER adds the predicate function <code>twos-complement-p</code>, when you need to test the minimum bit length for the two&apos;s complement rule.  This is required where padding bit-vectors, octet-vectors, or hex-strings with leading zeros up to a set word-length is expected.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">twos-complement-p 256</span>)</span> =&gt; NIL
<span class="paren1">(<span class="code">twos-complement-p 255</span>)</span> =&gt; T</span></code></pre>

<h3>License</h3>

<p>Copyright &copy; 2014&ndash;2015, &ldquo;the Phoeron&rdquo; Colin J.E. Lupton. This project is released under the MIT License; please see <code>bit-smasher/LICENSE</code> for more information.</p>
