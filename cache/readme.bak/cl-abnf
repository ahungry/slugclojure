<h1>ABNF DEFINITION OF ABNF</h1>

<p>This Common Lisp librairie implements a parser generator for the ABNF
grammar format as described in <a href="http://tools.ietf.org/html/rfc2234" >RFC2234</a>.</p>

<p>The generated parser is a regular expression scanner provided by the
<a href="http://weitz.de/cl-ppcre/" >cl-ppcre</a> lib, which means that we can&apos;t parse
recursive grammar definition. One such definition is the ABNF definition as
given by the RFC. Fortunately, as you have this lib, you most probably don&apos;t
need to generate another parser to handle that particular ABNF grammar.</p>

<h2>Installation</h2>

<p>The system has been made Quicklisp ready.</p>

<pre><code>$ cd ~/quicklisp/local-projects/
$ git clone https://github.com/dimitri/cl-abnf.git
* (ql:quickload &quot;abnf&quot;)
</code></pre>

<p>Currently the ABNF system is maintained as part of the <code>pgloader</code> tool as a
central piece of its syslog message parser facility.</p>

<h2>Usage</h2>

<p>The <code>parse-abnf-grammar</code> function expects the grammar to be parsed as a
string, and also needs the top level rule name of the grammar you&apos;re
interested into, as a symbol or a string. You can also give a list of rule
names that you want to capture, they will be capture in the order in which
they are needed to expand the given top-level rule.</p>

<p>The <code>parse-abnf-grammar</code> function returns a <code>cl-ppcre</code> scanner.</p>

<p>~~~ {#example.lisp .commonlisp .numberLines}
(defvar <em>timestamp-abnf</em>
  &quot;   TIMESTAMP       = NILVALUE / FULL-DATE &quot;T&quot; FULL-TIME
      FULL-DATE       = DATE-FULLYEAR &quot;-&quot; DATE-MONTH &quot;-&quot; DATE-MDAY
      DATE-FULLYEAR   = 4DIGIT
      DATE-MONTH      = 2DIGIT  ; 01-12
      DATE-MDAY       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                                ; month/year
      FULL-TIME       = PARTIAL-TIME TIME-OFFSET
      PARTIAL-TIME    = TIME-HOUR &quot;:&quot; TIME-MINUTE &quot;:&quot; TIME-SECOND
                        [TIME-SECFRAC]
      TIME-HOUR       = 2DIGIT  ; 00-23
      TIME-MINUTE     = 2DIGIT  ; 00-59
      TIME-SECOND     = 2DIGIT  ; 00-59
      TIME-SECFRAC    = &quot;.&quot; 1*6DIGIT
      TIME-OFFSET     = &quot;Z&quot; / TIME-NUMOFFSET
      TIME-NUMOFFSET  = (&quot;+&quot; / &quot;-&quot;) TIME-HOUR &quot;:&quot; TIME-MINUTE</p>

<pre><code>  NILVALUE        = \&quot;-\&quot; &quot;
</code></pre>

<p>&ldquo;A timestamp ABNF grammar.&rdquo;)</p>

<p>(let ((scanner (abnf:parse-abnf-grammar <em>timestamp-abnf</em>
                    :timestamp
                    :registering-rules &apos;(:full-date))))
  (cl-ppcre:register-groups-bind (date)
      (scanner &ldquo;2013-09-08T00:02:03.123456Z+02:00&rdquo;)
    date))
~~~</p>

<p>In the previous usage example the <code>let</code> block returns <code>&quot;2013-09-08&quot;</code>.</p>

<h2>ABNF grammar</h2>

<p>This library supports the ABNF grammar as given in RFC 2234, with additional
support for plain regular expressions.</p>

<h3>Parsed grammar</h3>

<p>Here&apos;s the RFC syntax:</p>

<pre><code>    rulelist       =  1*( rule / (*c-wsp c-nl) )

    rule           =  rulename defined-as elements c-nl
                           ; continues if next line starts
                           ;  with white space

    rulename       =  ALPHA *(ALPHA / DIGIT / &quot;-&quot;)

    defined-as     =  *c-wsp (&quot;=&quot; / &quot;=/&quot;) *c-wsp
                           ; basic rules definition and
                           ;  incremental alternatives

    elements       =  alternation *c-wsp

    c-wsp          =  WSP / (c-nl WSP)

    c-nl           =  comment / CRLF
                           ; comment or newline

    comment        =  &quot;;&quot; *(WSP / VCHAR) CRLF

    alternation    =  concatenation
                      *(*c-wsp &quot;/&quot; *c-wsp concatenation)

    concatenation  =  repetition *(1*c-wsp repetition)

    repetition     =  [repeat] element

    repeat         =  1*DIGIT / (*DIGIT &quot;*&quot; *DIGIT)

    element        =  rulename / group / option /
                      char-val / num-val / prose-val / regex
                           ; regex is an addition of this lib, see above

    group          =  &quot;(&quot; *c-wsp alternation *c-wsp &quot;)&quot;

    option         =  &quot;[&quot; *c-wsp alternation *c-wsp &quot;]&quot;

    char-val       =  DQUOTE *(%x20-21 / %x23-7E) DQUOTE
                           ; quoted string of SP and VCHAR
                           ;   without DQUOTE

    num-val        =  &quot;%&quot; (bin-val / dec-val / hex-val)

    bin-val        =  &quot;b&quot; 1*BIT
                      [ 1*(&quot;.&quot; 1*BIT) / (&quot;-&quot; 1*BIT) ]
                           ; series of concatenated bit values
                           ; or single ONEOF range

    dec-val        =  &quot;d&quot; 1*DIGIT
                      [ 1*(&quot;.&quot; 1*DIGIT) / (&quot;-&quot; 1*DIGIT) ]

    hex-val        =  &quot;x&quot; 1*HEXDIG
                      [ 1*(&quot;.&quot; 1*HEXDIG) / (&quot;-&quot; 1*HEXDIG) ]

    prose-val      =  &quot;&lt;&quot; *(%x20-3D / %x3F-7E) &quot;&gt;&quot;
                           ; bracketed string of SP and VCHAR
                           ;   without angles
                           ; prose description, to be used as
                           ;   last resort
</code></pre>

<h3>Core rules</h3>

<p>Those parts of the grammar are always provided, they are the <em>defaults</em>
rules of the ABNF definition.</p>

<pre><code>    ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z

    BIT            =  &quot;0&quot; / &quot;1&quot;

    CHAR           =  %x01-7F
                           ; any 7-bit US-ASCII character, excluding NUL

    CR             =  %x0D
                           ; carriage return

    CRLF           =  CR LF
                           ; Internet standard newline

    CTL            =  %x00-1F / %x7F
                           ; controls

    DIGIT          =  %x30-39
                           ; 0-9

    DQUOTE         =  %x22
                           ; &quot; (Double Quote)

    HEXDIG         =  DIGIT / &quot;A&quot; / &quot;B&quot; / &quot;C&quot; / &quot;D&quot; / &quot;E&quot; / &quot;F&quot;

    HTAB           =  %x09
                           ; horizontal tab

    LF             =  %x0A
                           ; linefeed

    LWSP           =  *(WSP / CRLF WSP)
                           ; linear white space (past newline)

    OCTET          =  %x00-FF
                           ; 8 bits of data

    SP             =  %x20
</code></pre>

<h3>Regex Support</h3>

<p>We add support for plain regexp in the <code>element</code> rule. A regexp is expected
to follow the form:</p>

<pre><code>   regex           = &quot;~&quot; delimiter expression delimiter
</code></pre>

<p>The <em>expression</em> shouldn&apos;t contain the <em>delimiter</em> of course, and the
allowed delimiters are <code>~//</code>, <code>~[]</code>, <code>~{}</code>, <code>~()</code>, <code>~&lt;&gt;</code>, <code>~&quot;&quot;</code>, <code>~''</code>,
<code>~||</code> and <code>~##</code>. If you have to build a regexp with more than one of those
delimiters in it, you can just concatenate multiple parts together like in
this example:</p>

<pre><code> complex-regex  = ~/foo{bar}/ ~{baz/quux}
</code></pre>

<p>That will be used in exactly the same way as the following example:</p>

<pre><code> complex-regex  = ~&lt;foo{bar}baz/quux&gt;
</code></pre>
