<h1>FMT</h1>

<p><strong>FMT</strong> is an extensible text formatting facility for Common Lisp. It is
meant to do the same things Common Lisp <strong>FORMAT</strong> function does, but
instead of using a control-string for formatting directives, it uses
s-expressions.</p>

<h1>Invocation</h1>

<h2>with-fmt</h2>

<p>A macro that expands its body to formatting commands.</p>

<p><code>destination</code> can be:</p>

<ul>
<li>NIL: formatting is done on a new string that is returned as result</li>
<li>T: formatting is printed to <code>*standard-output*</code></li>
<li>a stream: formatting is written to the stream</li>
</ul>

<p>If no <code>destination</code> is given, then <code>*fmt-destination*</code> is the default
destination.</p>

<p>Body forms are either some lisp object, like strings, numbers,
characters, etc; or some formatting operation. A formatting operation
has the form of a list beggining with the operation keyword, like
<code>(:aesthetic message)</code>, <code>(:join &quot;,&quot; list)</code>, etc. Forms appearing in body
are formatted one after the other.</p>

<p>Example:</p>

<pre><code>(with-fmt ()
   &quot;Hello world&quot;
   #\newline
   (:join &quot;,&quot; (list 1 2 3)))
</code></pre>

<p>prints:</p>

<pre><code>Hello world
1,2,3
</code></pre>

<h2>fmt</h2>

<p>This macro is almost exactly to <code>with-fmt</code>, but with a different syntax,
with makes it look very similar to Common Lisp <code>format</code> function.</p>

<p>Example:</p>

<pre><code>(fmt nil &quot;Hello&quot; \#space &quot;world&quot;)
(fmt t (:s (list 1 2 3)))
</code></pre>

<h2>fmt*</h2>

<p>Both <code>fmt</code> and <code>with-fmt</code> are macros and compile formatting directives
to code that writes on the destination stream at compile-time. <code>fmt*</code> is
a function, and interprets the formatting clauses given to it at
run-time. This can be useful if you need a function to pass around, or
you need extra flexibility in the formatting spec form.</p>

<p>Example:</p>

<pre><code>(fmt* nil &quot;Hello&quot; #\space &quot;world&quot;)
(fmt* nil (if t `(:d ,22) `(:f ,23.44)))
</code></pre>

<p>Note that some control flow operations (like <code>:do</code> and <code>:if</code> are not
available in interpreted mode).</p>

<h1>Printer operations</h1>

<h2>Aesthetic (:a, :aesthetic)</h2>

<p>The aesthetic operation is the equivalent of Common Lisp <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/22_cda.htm" >FORMAT&apos;s
\~A</a>
directive.</p>

<p>Example:</p>

<pre><code>(fmt nil (:a (list :foo :bar :baz)))
</code></pre>

<p>returns <code>&quot;(FOO BAR BAZ)&quot;</code></p>

<h2>Standard (:s, :std, :standard)</h2>

<p>The standard operation is the equivalent of Common Lisp <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/22_cdb.htm" >FORMAT&apos;s
\~S</a>
directive.</p>

<p>Example:</p>

<pre><code>(fmt nil (:s (list :foo :bar :baz)))
</code></pre>

<p>returns <code>&quot;(:FOO :BAR :BAZ)&quot;</code></p>

<h1>Special operations</h1>

<h2>Escaping (:esc and :fmt)</h2>

<p>Use the <code>:esc</code> directive for disabling formatting in a particular place.</p>

<p>For instance:</p>

<pre><code>(fmt nil &quot;Hello&quot; #\space (:esc &quot;beautiful&quot; #\space) &quot;world&quot;)
</code></pre>

<p>returns <code>&quot;hello world&quot;</code></p>

<p>It&apos;s important to note that the code inside :esc is not removed
completly, it is executed, but its result is not formatted. You can see
that in the macroexpansion of the above code:</p>

<pre><code>(WITH-FMT-DESTINATION (#:STREAM925 NIL)
  (MACROLET ((:FMT (&amp;REST CLAUSES)
            `(FMT ,'#:STREAM925 ,@CLAUSES)))
  (WRITE-STRING &quot;Hello&quot; #:STREAM925)
  (WRITE-CHAR #\  #:STREAM925)
  (PROGN &quot;beautiful&quot; #\ )
  (WRITE-STRING &quot;world&quot; #:STREAM925)))
</code></pre>

<p>This is useful in combination with the <code>:fmt</code> directive, that reenables
formatting inside escaped forms:</p>

<pre><code>(fmt nil 
     (:a &quot;start&quot;)
 #\newline
 (:esc 
   (loop for x in (list 1 2 3)
   do (:fmt (:s x))))
 #\newline
 (:a &quot;end&quot;))
</code></pre>

<p>In the above example the output of the loop is not formatted as it is
enclosed in an <code>:esc</code>; but the <code>:fmt</code> operation inside the loops makes
sure each of the elements of the list is formatted.</p>

<h1>Control flow operations</h1>

<h2>Conditional (:when and :if)</h2>

<p>Conditional control flow can be controlled via <code>:when</code> and <code>:if</code>
operations.</p>

<p><code>:when</code> is the simplest of the two and executes its body when the
condition given is true.</p>

<p>Syntax:</p>

<pre><code>(:when condition &amp;body body)
</code></pre>

<p>Example:</p>

<pre><code>(let ((cond t))
    (fmt nil (:when cond &quot;yes&quot;))) ;=&gt; &quot;yes&quot;

(let ((cond nil))
 (fmt nil (:when cond &quot;yes&quot;))) ;=&gt; &quot;&quot;
</code></pre>

<p><code>:if</code> has an <code>else</code> branch.</p>

<p>Syntax:</p>

<pre><code>(:if condition &amp;body body)
</code></pre>

<p>The <code>else</code> branch is indicated with the <code>:else</code> keyword.</p>

<p>Example:</p>

<pre><code>(let ((list (list 1 2 3)))
  (fmt nil (:if (not list)
                 &quot;none&quot;
         :else
         (:join &quot;,&quot; list)))) ;=&gt; &quot;1,2,3&quot;

 (let ((list (list)))
   (fmt nil (:if (not list)
          &quot;none&quot;
          :else
          (:join &quot;,&quot; list)))) ;=&gt; &quot;none&quot;
</code></pre>

<p>Note: <code>:if</code> is not implemented in interpreter mode, so it cannot be used
in <code>fmt*</code> function.</p>

<h2>Iteration (:do)</h2>

<p>To iterate a list formatting its elements, there&apos;s the <code>:do</code> operation.</p>

<p>Syntax:</p>

<pre><code>(:do (var list) &amp;body body)
</code></pre>

<p>Example:</p>

<pre><code>(fmt nil (:do (item (list 1 2 3))
              (:s item))) ;=&gt; &quot;123&quot;
</code></pre>

<p>Note: <code>:do</code> is not implemented in interpreter mode, so it cannot be used
in <code>fmt*</code> function.</p>

<h2>Repetition (:times)</h2>

<p>Repeat formatting N number of times</p>

<p>Syntax:</p>

<pre><code>(:times clause n)
</code></pre>

<p>Example:</p>

<pre><code>(fmt nil (:times #\newline 5))
</code></pre>

<h2>More complex control flow</h2>

<p>Just use lisp with <code>:esc</code> and <code>:fmt</code> for more complex control flow.</p>

<p>Example:</p>

<pre><code>(let ((list (list 1 2 3)))
  (fmt nil (:esc (if (not list)
                   (:fmt &quot;No elements&quot;)
                   (loop for x in (butlast list)
                         do (:fmt (:a x) &quot;; &quot;)
                         finally (:fmt (:a (car (last list)))))))))           
</code></pre>

<h1>Other operations</h1>

<h2>Join (:join)</h2>

<p>Joins the elements of its list argument using a separator.</p>

<p>Syntax:</p>

<pre><code>(:join separator list &amp;optional format)
</code></pre>

<p><code>separator</code> can be either be a character or a string. <code>list</code> is of
course the list of elements to join. <code>format</code>, if present, is a command
for formatting the list elements. If it is not present <code>:s</code> is used. <code>_</code>
is bound to the list element.</p>

<p>Example:</p>

<pre><code>(fmt nil (:join &quot;, &quot; (list &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;))) ;=&gt; &quot;foo, bar, baz&quot;
(fmt nil (:join #\, (list &quot;foo&quot; &quot;bar&quot;))) ;=&gt; &quot;foo,bar&quot;
(fmt nil (:join (&quot;, &quot; &quot; and &quot;)
             (list &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;))) ;=&gt; &quot;foo, bar and baz&quot;
(fmt nil (:join &quot;, &quot; (list &quot;a&quot; &quot;b&quot; &quot;c&quot;) (:a _ :up))) ;=&gt; &quot;A, B, C&quot;
</code></pre>

<h2>Common Lisp format (:format)</h2>

<p>It is possible to just invoke Common Lisp format function to write on
the current destination.</p>

<p>Syntax:</p>

<pre><code>(:format control-string &amp;rest args)
</code></pre>

<p>Example:</p>

<pre><code>(let ((list (list &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;)))
 (fmt nil (:format &quot;~{~A~^, ~}&quot; list))) ;=&gt; &quot;foo, bar, baz&quot;

(let ((list (list :foo :bar :baz)))
 (fmt nil (:format &quot;~{~S~^, ~}&quot; list))) ;=&gt; &quot;:FOO, :BAR, :BAZ&quot;
</code></pre>

<h1>Filters</h1>

<p>Filters are particular operations or functions that modify the input
before it gets formatted.</p>

<p>aesthetic and standard operations support filters.</p>

<p>Filters appear at the end of the <code>:a</code> or <code>:s</code> operations:</p>

<pre><code>(:a arg &amp;rest filters)
(:s arg &amp;rest filters)
</code></pre>

<p>Filters can be either a function reference or some previously defined
filter.</p>

<p>Example:</p>

<pre><code>(fmt nil (:a &quot;foo&quot; :upcase)) ;=&gt; &quot;FOO&quot;
(fmt nil (:s &quot;foo&quot; #'string-upcase)) ;=&gt; &quot;FOO&quot;
(fmt nil (:a &quot;  foo  &quot; (:trim #\ ) :up)) ;=&gt; &quot;FOO&quot;
</code></pre>

<p>Some very common filters are <code>:upcase</code> or <code>:up</code>, <code>:downcase</code> or <code>:down</code>,
<code>:trim</code>, etc</p>

<h1>Radix control</h1>

<h2>Radix (:r, :radix)</h2>

<p>Prints argument in radix. Equivalent to <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/22_cba.htm" >Common Lisp FORMAT&apos;s
\~R</a></p>

<p>Syntax:</p>

<pre><code>(:r n &amp;optional (interpretation :cardinal))
</code></pre>

<p><code>interpretation</code> can be <code>:cardinal</code>, <code>:ordinal</code>, <code>:roman</code> and
<code>:old-roman</code>.</p>

<p>Examples:</p>

<pre><code>(fmt nil (:r 4)) ;=&gt; &quot;four&quot;
(fmt nil (:r 4 :cardinal)) ;=&gt; &quot;four&quot;
(fmt nil (:r 4 :ordinal)) ;=&gt; &quot;fourth&quot;
(fmt nil (:r 4 2)) ;=&gt; &quot;100&quot;
(fmt nil (:r 4 :roman)) ;=&gt; &quot;IV&quot;
(fmt nil (:r 4 :old-roman)) ;=&gt; &quot;IIII&quot;
</code></pre>

<h1>Extending FMT</h1>

<h2>Custom formatting operations definition</h2>

<p>Custom formatting operations can be defined via
<code>define-format-operation</code> macro.</p>

<p>It has the following syntax:</p>

<pre><code>(define-format-operation operation-name
   (:keywords keyword-list)
   (:format (destination clause)
         &amp;body body)
   (:compile (destination clause)
         &amp;body body)
   (:documentation docstring))
</code></pre>

<p>Where:</p>

<ul>
<li><code>keyword-list</code> is a list of keywords with which the formatting
operation can be invoked.</li>
<li><code>format</code> is the function that is run at run-time for formatting with
<code>fmt*</code> function. <code>destination</code> is the current formatting
destination, and <code>clause</code> is the whole format clause.</li>
<li><code>compile</code> is the code transformation triggered at compile-time by
<code>fmt</code> and <code>with-fmt</code> macros. It is expected to return a piece of
code.</li>
<li><code>documentation</code> is the operation description string.</li>
</ul>

<p>For example, we can define a time formatting operation</p>

<pre><code>(define-format-operation time
    (:keywords (:time))
    (:format (destination clause)
     (destructuring-bind (_ timestamp &amp;optional (format local-time:+iso-8601-format+)) clause
         (declare (ignore _))
         (let ((local-time (etypecase timestamp
                 (integer
                  (local-time:universal-to-timestamp timestamp))
                 (local-time:timestamp
                  timestamp))))
           (local-time:format-timestring destination 
                         local-time
                         :format format))))
    (:compile (destination clause)
      (destructuring-bind (_ timestamp &amp;optional (format 'local-time:+iso-8601-format+)) clause
          (declare (ignore _))
          (alexandria:with-unique-names (local-time)
            (alexandria:once-only (timestamp)
            `(let ((,local-time (etypecase ,timestamp
                      (integer
                       (local-time:universal-to-timestamp ,timestamp))
                      (local-time:timestamp
                       ,timestamp))))
           (local-time:format-timestring ,destination 
                         ,local-time
                         :format ,format))))))
    (:documentation &quot;Time formatting&quot;))
</code></pre>

<p>And then we can use the new operation like this:</p>

<pre><code>(fmt* nil `(:time ,(get-universal-time)))
</code></pre>

<p>That goes through the operation&apos;s <code>:format</code> code.</p>

<pre><code>(fmt nil (:time (get-universal-time)))
</code></pre>

<p>Which transforms code using the operation&apos;s <code>:compile</code> code.</p>

<h2>Custom filters definition</h2>

<p>Filters are defined via <code>define-format-filter</code> macro, very similarly to
format operations.</p>

<p>Syntax:</p>

<pre><code>(define-format-filter filter-name
   (:keywords keyword-list)
   (:apply (arg)
         &amp;body body)
   (:compile (arg)
         &amp;body body)
   (:documentation docstring))
</code></pre>

<p>Where:</p>

<ul>
<li><code>keyword-list</code> is a list of keywords with which the filter can be
applied.</li>
<li><code>apply</code> is the function that is run at run-time for formatting with
<code>fmt*</code> function. <code>arg</code> is the argument to which apply the filter.</li>
<li><code>compile</code> is the code transformation triggered at compile-time by
<code>fmt</code> and <code>with-fmt</code> macros. It is expected to return a piece of
code.</li>
<li><code>documentation</code> is the operation description string.</li>
</ul>

<p>For example, the <code>:trim</code> filter is defined like this:</p>

<pre><code>(define-format-filter trim
   (:keywords (:trim))
   (:apply (arg &amp;rest chars)
       (string-trim (or chars (list #\ )) arg))
   (:compile (arg &amp;rest chars)
     (let ((chars-bag (or chars (list #\ ))))
       `(string-trim ',chars-bag ,arg)))
   (:documentation &quot;String trim filter&quot;))
</code></pre>

<p>Filters can be used in <code>:a</code> and <code>:s</code> operations afterwards:</p>

<pre><code>(fmt nil (:a &quot;  hello  &quot; :trim)) ;=&gt; &quot;hello&quot;
(fmt nil (:a &quot;//hello&quot; (:trim #\/))) ;=&gt; &quot;hello&quot;
</code></pre>
