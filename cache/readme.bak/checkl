<h1>CheckL</h1>

<p>Why write programs in Common Lisp but tests like Java?</p>

<p>My workflow for writing Common Lisp tends to be like this:</p>

<ul>
<li>Write a bit of lisp, perhaps a function, class, or structure</li>
<li>Write a snippet in a scratch buffer to test</li>
<li>Fix if necessary and repeat</li>
</ul>

<p>Testing is already inherent in this process, all we need is a little
bit of Common Lisp magic to take advantage of it.  Thus, CheckL:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">+ 1 1</span>)</span></span>)</span>

<span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"></span>)</span> <span class="paren2">(<span class="code">foo</span>)</span></span>)</span> <span class="comment">;; =&gt; 2
</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">+ 1 2</span>)</span></span>)</span>

<span class="paren1">(<span class="code">check <span class="paren2">(<span class="code"></span>)</span> <span class="paren2">(<span class="code">foo</span>)</span></span>)</span>

    |
    v

Result 0 has changed: 3
Previous result: 2
   [Condition of type CHECKL::RESULT-ERROR]

Restarts:
 0: [USE-NEW-VALUE] The new value is correct, use it from now on.
 1: [SKIP-TEST] Skip this, leaving the old value, but continue testing
 2: [RETRY] Retry SLIME interactive evaluation request.
 3: [*ABORT] Return to SLIME's top level.
 4: [TERMINATE-THREAD] Terminate this thread (#&lt;THREAD "worker" RUNNING {100586AB13}&gt;)</span></code></pre>

<p><a href="http://rpav.github.com/CheckL" >See the full documentation for more details!</a></p>
