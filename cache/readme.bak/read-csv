<h1>read-csv</h1>

<h1>1 Overview</h1>

<p>read-csv is a stream oriented CSV (comma-separated value) reader that supports excel .csv files.</p>

<pre><code>(with-open-file (s &quot;/path/to/csv&quot;)
  (parse-csv s))
</code></pre>

<p>;; Returns a list of lists of strings.</p>

<h2>1.1 Features</h2>

<ul>
<li>Low line of code count (around 50 lines of code)</li>
<li>Supports quotes, including newlines and separator characters within the quotes.</li>
<li>Supports Unix style LF line endings and Dos CRLF line endings. (automatically)</li>
</ul>

<h1>2 Installation</h1>

<h2>2.1 Quick Lisp</h2>

<p>Install <a href="http://www.quicklisp.org/beta/" >Quick Lisp</a> and then run:</p>

<p>(ql:quickload &apos;read-csv)</p>

<p>If you have problems, see the <a href="#support" >support</a> section, and you may want to <a href="#runtests" >run the tests</a>.</p>

<h2>2.2 Gentoo</h2>

<p>As root, </p>

<p>emerge read-csv</p>

<p>Once the emerge is finished, the package can be loaded using ASDF:</p>

<p>(asdf:operate &apos;asdf:load-op :read-csv)</p>

<p>If you have problems, see the <a href="#support" >support</a> section, otherwise you may want to <a href="#runtests" >run the tests</a>.</p>

<h2>2.3 Ubunto</h2>

<p>sudo apt-get install read-csv</p>

<p>Once the installation is finished, the package is loadable using ASDF:</p>

<p>(asdf:operate &apos;asdf:load-op :read-csv)</p>

<p>If you have problems, see the <a href="#support" >support</a> section, otherwise you may want to <a href="#runtests" >run the tests</a>.</p>

<h2>2.4 Manual Installation</h2>

<p>In summary: Untar the <a href="https://github.com/WarrenWilkinson/read-csv/archive/master.tar.gz" >.tar</a> package and then symlink the .asd files into a place where ASDF can find them. </p>

<ol>
<li>Untar the files where you want them to be.  On windows download the <a href="https://github.com/WarrenWilkinson/read-csv/archive/master.zip" >.zip</a> and unzip it instead, it&apos;s the same files.</li>
<li>ASDF could be looking anywhere &ndash; it depends on your setup.  Run this in your lisp repl to get a clue
 as to where ASDF is seeking libraries[1]:</li>
</ol>

<p>(mapcan #&apos;funcall asdf:<em>default-source-registries</em>)</p>

<ol>
<li>Symlink the .asd files to the source directory. If you use windows, <a href="http://bc.tech.coop/blog/041113.html" >these instructions on symlink alternatives apply to you</a>.</li>
</ol>

<p>Once the files are in place, the package can be loaded with ASDF by:</p>

<p>(asdf:operate &apos;asdf:load-op :read-csv)</p>

<p>If you have problems, see the <a href="#support" >support</a> section.  If you don&apos;t have problems you may want to <a href="#runtests" >run the tests</a> anyway, because you can.</p>

<h2>2.5 Running the Tests</h2>

<p>Once the system is loaded, it can be tested with asdf. </p>

<p>(asdf:operate &apos;asdf:test-op :read-csv)</p>

<p>This should display something like the following. There should
be <em>zero failures</em>, if you have failures see the <a href="#support" >support</a> section
of this document.</p>

<p>RUNNING READ-CSV TESTS&hellip;
  READ-CSV TEST RESULTS: 
       Tests: 519
     Success: 519
    Failures: 0</p>

<pre><code>[support]: #support
</code></pre>

<h2>2.6 Getting Support</h2>

<p>You can find support on this libraries <a href="http://warrenwilkinson.ca/read-csv" >website</a> and/or <a href="https://github.com/WarrenWilkinson/read-csv" >github</a> repository. Or you can email <a href="mailto:warrenwilkinson@gmail.com" >Warren Wilkinson</a>.</p>

<h1>3 Implementation</h1>

<p>Most Lisp CSV readers hover around 400 lines of code. This one is 68. </p>

<p>The difference is this one is coded as state machine in a dense 2D grid, as described in <a href="http://galileo.phys.virginia.edu/classes/551.jvn.fall01/fsm.html" >FINITE State Machines in Forth</a>. &ldquo;If you are in this /state/ and you see
this /character/ then you &hellip;&rdquo; </p>

<p><em>state</em>     <em>white</em>          <em>return</em>        <em>linefeed</em>     <em>quote</em>          <em>separator</em>    <em>other</em><br/>
 &mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;-
  <em>start</em>     noop &rarr;start     ship &rarr;return   ship &rarr;done!   noop &rarr;quote     next &rarr;start   addc &rarr;unquote<br/>
  <em>return</em>    noop &rarr;start     ship &rarr;return   noop &rarr;done!   noop &rarr;start     next &rarr;start   addc &rarr;unquote<br/>
  <em>unquote</em>   addc &rarr;unquote   ship &rarr;return   ship &rarr;done!   addc &rarr;unquote   next &rarr;start   addc &rarr;unquote<br/>
  <em>quote</em>     addc &rarr;quote     noop &rarr;q+ret    addl &rarr;quote   noop &rarr;q+quote   addc &rarr;quote   addc &rarr;quote<br/>
  <em>q+ret</em>     addc &rarr;quote     noop &rarr;q+ret    addl &rarr;quote   noop &rarr;q+quote   addc &rarr;quote   addc &rarr;quote<br/>
  <em>q+quote</em>   noop &rarr;q+q&amp;w     ship &rarr;return   ship &rarr;done!   addc &rarr;quote     next &rarr;start   addc &rarr;unquote<br/>
  <em>q+q&amp;w</em>     noop &rarr;q+q&amp;w     ship &rarr;return   ship &rarr;done!   addc &rarr;quote     next &rarr;start   addc &rarr;unquote  </p>

<p>1) perform the designated function, and 2) transition to the designated new state. </p>

<p>For example, if we start /(e.g. state start)/ and spot quote, then we perform noop and change to quote state.
Then, in the quote state, if we spot &lsquo;/A/&rsquo;, perform &lsquo;addc&rsquo; (add character) and remain in the quote state. </p>

<h2>3.1 Collecting the Input</h2>

<p>The functions used by the above table are:</p>

<p>noop: Do no action
  addc: Add a character to the current CSV record.
  addl: Add a newline character to the current CSV record.
  next: Finish the current CSV record and start the next.
  ship: Cleanup the current set of CSV records for returning them to the end user.</p>

<p>Internally, these methods play with three dynamic variables:  <em>*record*</em> and <em>*records*</em> and <em>*white-char-count*</em>. 
The first, during run time, holds a list of characters &ndash; in reverse order. The second holds the list of parsed records &ndash; also in
reverse order (but each record in proper order).  The <em>next</em> method reverses the order and coerces the csv data to
a string. The <em>ship</em> method reverses the <em>*records*</em> list so it&apos;s in proper order.</p>

<p>The last variable, *white-char-count* keeps a count of how many characters we&apos;ve seen since after the quote. It&apos;s used
to let us to remove whitespace characters after the closing quote without removing whitespace characters within
the quotes.</p>

<p>(defun noop (c) (declare (ignore c)))
  (defun addc (c) (push c <em>record</em>))
  (defun addl (c) (declare (ignore c)) (push #\Newline <em>record</em>))
  (flet ((white (c) (or (char= c #\Space) (char= c #\Tab))))
    (defun next (c) 
      (declare (ignore c))
      (let ((eow (or (position-if-not #&apos;white <em>record</em>) (length <em>record</em>))))
        (push (coerce (nreverse (nthcdr (max 0 (min eow (1- <em>white-char-count</em>))) <em>record</em>)) &apos;string) <em>records</em>))
      (setf <em>record</em> nil)))
  (defun ship (c) (next c) (setf <em>records</em> (nreverse <em>records</em>)))</p>

<h2>3.2 Traversing the Input</h2>

<p>We read CSV by running our state machine until the /done/ state is reached. </p>

<p>(defun char-class (sep char)
    (case char (#\Space 0) (#\Return 1) (#\Linefeed 2) (#&quot; 3) (otherwise (if (char= sep char) 4 5))))</p>

<p>(defun read-csv (stream &amp;optional (sep #\,) (eof-error-p t) eof-value)
    &ldquo;Return CSV data and a second value that&apos;s true if row ended by EOF.&rdquo;
    (let ((<em>records</em> nil)
          (<em>record</em> nil)
          (<em>white-char-count</em> 0))
      (declare (special <em>record</em> <em>records</em> <em>white-char-count</em>))
      (loop with state = start
            for char = (read-char stream (and (null <em>records</em>) eof-error-p) :eof)
            when (eq char :eof) 
            do (return-from read-csv (values (if <em>records</em> (ship :eof) eof-value) t))
            do (incf <em>white-char-count</em>)
            do (let ((class (char-class sep char)))
                 (when (= class quote) (setf <em>white-char-count</em> 0))
                 (funcall (aref +csv-table+ state class 0) char)
                 (setf state (aref +csv-table+ state class 1)))
         until (eq state done!))
      (values <em>records</em> (eq :eof (peek-char nil stream nil :eof)))))</p>

<h2>3.3 Parsing whole files: parse-csv</h2>

<p>To parse a whole file, the utility parse-csv calls read-csv until the end-of-file.</p>

<p>(defun parse-csv (stream  &amp;optional (sep #\,))
    (loop for (line end-p) = (multiple-value-list (read-csv stream sep nil :eof))
          unless (eq line :eof) collect line
          until end-p))</p>

<h2>3.4 Test Framework</h2>

<p>The test framework combines jumbles of CSV statements and calls read-csv on them.  In practice it means I take
(upto) 5 patterns, sequentially, from the a predefined list of hard patterns.  Then I take all permutations
(120, if 5 patterns) and combine them as 1 record per row (and 5 rows), 2 per row, 3 per row, 4 per row and 5 per row.
Then I test that I can parse it back correctly.</p>

<p>The jumbler is shown below, but I also test parse-csv by parsing larger examples but that is not shown here.</p>

<p>(defun concat-with (strings item)
    (if (null strings)
        &quot;&quot;
        (apply #&apos;concatenate &lsquo;string (first strings) (mapcan #&rsquo;(lambda (a) (list item a)) (rest strings)))))</p>

<p>(defun build-answers (i strings)
    (loop while strings
          collect (loop for n upto (1- i)
                        while strings 
                        collect (car strings)
                        do (setf strings  (cdr strings)))))</p>

<p>(defun build-string (i strings)
    (concatenate &lsquo;string 
       (concat-with (mapcar #&rsquo;(lambda (s) (concat-with s &ldquo;,&rdquo;)) (build-answers i strings)) (list #\Newline))
       &apos;(#\Newline)))</p>

<p>(defun all-combinations (patterns) 
     (if (null (cdr patterns))
         (list patterns)
         (loop for i in patterns
               nconc (mapcar #&apos;(lambda (p) (cons i p)) (all-combinations (remove i patterns))))))</p>

<p>(defun make-test (description)
    #&apos;(lambda ()
        (block test
          ;(loop for pattern in (all-combinations description)
          (format t &ldquo;~%Pattern: ~s&rdquo; (substitute #' #&quot; (remove #\Newline (build-string (length description) (mapcar #&apos;car description)))))
          (dotimes (i (length description) t)
            (format t &ldquo;~%  @~d&rdquo; i)
            (let ((string (build-string (1+ i) (mapcar #&apos;car description)))
                  (answers (build-answers (1+ i) (mapcar #&apos;cdr description))))
              (with-input-from-string (s string)
                (loop for answer in answers
                      for (got end) = (multiple-value-list (read-csv s))
                      unless (equalp answer got)
                      do (format t &ldquo;~%Expected ~a, got ~a&rdquo; answer got)
                      and do (return-from test nil)
                      if (eq answer (car (last answers)))
                      unless end
                      do (format t &ldquo;~%Expected EOF, but didn&apos;t see it!&rdquo;)
                      unless (not end)
                      do (format t &ldquo;~%Did not expect EOF, but saw it!&rdquo;))
                (let ((read-more (read-csv s #\, nil :eof)))
                (unless (eq read-more :eof)
                  (format t &ldquo;~%Could read past end: ~s&rdquo; read-more)
                  (return-from test nil)))))))))</p>

<p>3.4.1 Parse-csv tests 
~~~~~~~~~~~~~~~~~~~~~~</p>

<p>These tests were yanked from <a href="https://github.com/AccelerationNet/cl-csv" >CL-CSV</a>, another Lisp CSV parser.</p>

<p>(defmacro deftest (name code result)
    `(defun ,name ()
       (format t &ldquo;~%~a&rdquo; &apos;,name)
       (let ((expect ,result)
             (got ,code))
         (if (equalp expect got)
             t
             (progn (format t &ldquo;~%Expected~% ~s~%but got~%~s&rdquo; expect got)
                    nil)))))</p>

<p>(defvar <em>a-tough-example-answer</em> &apos;((&ldquo;very tough&rdquo; &ldquo;easier to do&rdquo;)))
  (defun a-tough-example () 
    (with-input-from-string (s &ldquo;  &quot;very tough&quot;   ,    easier to do<br/>
  &rdquo;)
      (parse-csv s)))</p>

<p>(deftest test-tough (a-tough-example) <em>a-tough-example-answer</em>)</p>

<p>(defvar <em>big-example-answer</em>
    &apos;((&ldquo;first name&rdquo; &ldquo;last name&rdquo;   &ldquo;job &quot;title&quot;&rdquo;                      &ldquo;number of hours&rdquo; &ldquo;id&rdquo;)
      (&ldquo;Russ&rdquo;       &ldquo;Tyndall&rdquo;     &ldquo;Software Developer&apos;s, &quot;Position&quot;&rdquo; &ldquo;26.2&rdquo;            &ldquo;1&rdquo;)
      (&ldquo;Adam&rdquo;       &ldquo;Smith&rdquo;       &ldquo;Economist&rdquo;                          &ldquo;37.5&rdquo;            &ldquo;2&rdquo;)
      (&ldquo;John&rdquo;       &ldquo;Doe&rdquo;         &ldquo;Anonymous Human&rdquo;                    &ldquo;42.1&rdquo;            &ldquo;3&rdquo;)
      (&ldquo;Chuck&rdquo;      &ldquo;Darwin&rdquo;      &ldquo;Natural Philosopher&rdquo;                &ldquo;17.68&rdquo;           &ldquo;4&rdquo;)
      (&ldquo;Bill&rdquo;       &ldquo;Shakespeare&rdquo; &ldquo;Bard&rdquo;                               &ldquo;12.2&rdquo;            &ldquo;5&rdquo;)
      (&ldquo;James&rdquo;      &ldquo;Kirk&rdquo;        &ldquo;Starship Captain&rdquo;                   &ldquo;13.1&rdquo;            &ldquo;6&rdquo;)
      (&ldquo;Bob&rdquo;        &ldquo;Anon&rdquo;        &quot;&ldquo;                                   &rdquo;13.1&ldquo;            &rdquo;6&ldquo;)
      (&rdquo;Mr&ldquo;         &rdquo;Iñtërnâtiônàlizætiøn&ldquo; &rdquo;&ldquo;                          &rdquo;1.1&ldquo;             &rdquo;0&quot;)))</p>

<p>(defun big-example () 
    (with-input-from-string (s &ldquo;first name,last name,&quot;job &quot;&quot;title&quot;&quot;&quot;,number of hours,id
  Russ,Tyndall,&quot;Software Developer&apos;s, &quot;&quot;Position&quot;&quot;&quot;,26.2,1
  Adam,Smith,Economist,37.5,2
  John,Doe,Anonymous Human,42.1,3
  Chuck,Darwin,Natural Philosopher,17.68,4
  Bill,Shakespeare,Bard,12.2,5
  James,Kirk,Starship Captain,13.1,6
  Bob,Anon,,13.1,6
  Mr,Iñtërnâtiônàlizætiøn,,1.1,0&rdquo;)
      (parse-csv s)))</p>

<p>(defun quoted-big-example () 
    (with-input-from-string 
        (s &ldquo;&quot;first name&quot;,&quot;last name&quot;,&quot;job &quot;&quot;title&quot;&quot;&quot;,&quot;number of hours&quot;,&quot;id&quot;
  &quot;Russ&quot;,&quot;Tyndall&quot;,&quot;Software Developer&apos;s, &quot;&quot;Position&quot;&quot;&quot;,&quot;26.2&quot;,&quot;1&quot;
  &quot;Adam&quot;,&quot;Smith&quot;,&quot;Economist&quot;,&quot;37.5&quot;,&quot;2&quot;
  &quot;John&quot;,&quot;Doe&quot;,&quot;Anonymous Human&quot;,&quot;42.1&quot;,&quot;3&quot;
  &quot;Chuck&quot;,&quot;Darwin&quot;,&quot;Natural Philosopher&quot;,&quot;17.68&quot;,&quot;4&quot;
  &quot;Bill&quot;,&quot;Shakespeare&quot;,&quot;Bard&quot;,&quot;12.2&quot;,&quot;5&quot;
  &quot;James&quot;,&quot;Kirk&quot;,&quot;Starship Captain&quot;,&quot;13.1&quot;,&quot;6&quot;
  &quot;Bob&quot;,&quot;Anon&quot;,&quot;&quot;,&quot;13.1&quot;,&quot;6&quot;
  &quot;Mr&quot;,&quot;Iñtërnâtiônàlizætiøn&quot;,&quot;&quot;,&quot;1.1&quot;,&quot;0&quot;&rdquo;)
      (parse-csv s)))</p>

<p>(deftest test-big        (big-example)        <em>big-example-answer</em>)
  (deftest test-quoted-big (quoted-big-example) <em>big-example-answer</em>)</p>

<p>(defvar <em>multiline-answer</em>
    &apos;((&ldquo;this&rdquo; &ldquo;is&rdquo; &ldquo;a&rdquo; &ldquo;test
  of
  multiline&rdquo; &ldquo;data&rdquo;)
      (&ldquo;row2&rdquo; &ldquo;of&rdquo; &ldquo;the&rdquo; &ldquo;test
  of
  multiline&rdquo; &ldquo;data&rdquo;)))</p>

<p>(defun multiline-unix-example () 
    (with-input-from-string (s &ldquo;this,is,a,&quot;test
  of
  multiline&quot;, data
  row2,of,the,&quot;test
  of
  multiline&quot;, data&rdquo;)
      (parse-csv s)))</p>

<p>(defun multiline-dos-example ()
    (with-input-from-string 
        (s (concatenate &apos;string &ldquo;this,is,a,&quot;test&rdquo; (list #\Return #\Linefeed)
                        &ldquo;of&rdquo; (list #\Return #\Linefeed)
                        &ldquo;multiline&quot;, data&rdquo; (list #\Return #\Linefeed)
                        &ldquo;row2,of,the,&quot;test&rdquo; (list #\Return #\Linefeed)
                        &ldquo;of&rdquo; (list #\Return #\Linefeed)
                        &ldquo;multiline&quot;, data&rdquo; (list #\Return #\Linefeed)))
      (parse-csv s)))</p>

<p>(defun multiline-mixed-example ()
    (with-input-from-string
        (s (concatenate &apos;string &ldquo;this,is,a,&quot;test&rdquo; (list #\Linefeed)
                        &ldquo;of&rdquo; (list #\Return #\Linefeed)
                        &ldquo;multiline&quot;, data&rdquo; (list #\Return #\Linefeed)
                        &ldquo;row2,of,the,&quot;test&rdquo; (list #\Linefeed)
                        &ldquo;of&rdquo; (list #\Return #\Linefeed)
                        &ldquo;multiline&quot;, data&rdquo; (list #\Linefeed)))
      (parse-csv s)))</p>

<p>(deftest test-multiline-unix  (multiline-unix-example)  <em>multiline-answer</em>)
  (deftest test-multiline-dos   (multiline-dos-example)   <em>multiline-answer</em>)
  (deftest test-multiline-mixed (multiline-mixed-example) <em>multiline-answer</em>)</p>

<p>3.4.2 Running Tests 
~~~~~~~~~~~~~~~~~~~~</p>

<p>(defstruct results
    (tests 0)
    (failures nil))
  (defun results-failure-count (results)
    (length (results-failures results)))
  (defun results-successes (results)
    (- (results-tests results)
       (results-failure-count results)))</p>

<p>(defun runtest (fun results)
    (let* ((success t)
           (output (with-output-to-string (<em>standard-output</em>)
                     (setf success (handler-case (funcall fun)
                                     (error (e) (princ e) nil))))))
      (make-results
       :tests (1+ (results-tests results))
       :failures (if success
                     (results-failures results)
                     (acons fun output (results-failures results))))))</p>

<p>(defun present-failures (results)
    (format t &ldquo;~%READ-CSV FAILURES:~%&rdquo;)
    (loop for (fn . problems) in (results-failures results)
          do (format t &ldquo;~%~a~a~%&rdquo; fn problems)))
  (defun present-results (results)
    (format t &ldquo;~%READ-CSV TEST RESULTS:&rdquo;)
    (format t &ldquo;~%     Tests: ~a~%   Success: ~a~%  Failures: ~a&rdquo; 
            (results-tests results)
            (results-successes results)
            (results-failure-count results))
    (when (results-failures results)
      (present-failures results)))</p>

<p>(defun run-combination-tests (starting-results)
    (reduce #&lsquo;(lambda (description results) (runtest (make-test description) results))
             (nreverse (mapcan #&rsquo;(lambda (thing) (all-combinations (subseq thing 0 (min (length thing) 5))))
                      (loop for i on (reverse <em>all-statements</em>) collecting i)))
             :from-end t
             :initial-value starting-results))</p>

<p>(defun run-explicit-tests (starting-results)
    (reduce #&apos;(lambda (results function) (runtest function results))
             (list #&apos;test-tough
                   #&apos;test-big
                   #&apos;test-quoted-big
                   #&apos;test-multiline-unix
                   #&apos;test-multiline-dos
                   #&apos;test-multiline-mixed)
             :initial-value starting-results))</p>

<p>(defun run-tests ()
    (format t &ldquo;~%RUNNING READ-CSV TESTS&hellip;&rdquo;)
    (present-results (run-explicit-tests (run-combination-tests (make-results)))))</p>

<p>The bulk of the test code just has to do with collecting results and making pretty output.</p>

<h1>4 Tests Expressions</h1>

<p>This package is tested by combining tricky CSV parts in numerous ways, and then
ensuring the parser can parse them correctly.</p>

<h2>4.1 Blanks</h2>

<p><em>CSV</em>      <em>Should Parse</em>   <em>Note</em><br/>
 &mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
  &gt;&lt;         &gt;<               blank input                                             
  > \t &lt;     &gt;&lt;               whitespace input, <em>should be ignored.</em><br/>
  &gt;&quot;&ldquo;&lt;       &gt;&lt;               blank input, but quoted, should be empty<br/>
  &gt;&rdquo; \t &quot;&lt;   &gt; \t &lt;           blank input, but quoted, <em>should keep the whitespace.</em>  </p>

<h2>4.2 Quotes and Tricky Characters</h2>

<p><em>CSV</em>             <em>Should Parse</em>   <em>Note</em><br/>
 &mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
  &gt;&ldquo;multi\nline&rdquo;&lt;   &gt;multi\nline<    Multiline input should work                  
  >&ldquo;,&rdquo;&lt;             &gt;,<              Should be able to have seperator characters  
  >&quot;&quot;&quot;&ldquo;&lt;            &gt;&rdquo;&lt;              Double quotes should become a single quote.  </p>

<h2>4.3 International Text</h2>

<p><em>CSV</em>                         <em>Should Parse</em>             <em>Note</em><br/>
 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
  &gt;&ldquo;êve,y\nth还ng\tat&rdquo;&ldquo;once&rdquo;&lt;   &gt;êve,y\nth还ng\tat&quot;once&lt;   Everything at once  </p>

<h1>5 License</h1>

<p>Read-csv is distributed under the <a href="http://opensource.org/licenses/lgpl-2.1.php" >LGPL2</a> License. </p>

<p>[1] you might need to (require &apos;asdf) before running this example</p>
