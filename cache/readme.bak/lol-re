<h1>lol-re</h1>

<p>Tiny wrapper around CL-PPCRE, making usage of regexps more perly.
Inspired by let-over-lambda&apos;s #~m and #~s read-macro (http://www.letoverlambda.com)</p>

<p>This package introduces two car-reader-macro (see CL-READ-MACRO-TOKENS) M~ and S~ (and also MR~, see below).
M~ is for matching, MR~ is for matching with autoreset, while S~ is for substitution
(in direct analogy with Perl&apos;s &lsquo;=~ m//&rsquo; and &apos; =~ s///&apos; idioms).</p>

<p>M~
&ndash;</p>

<p>Syntax:</p>

<p><em>m~</em> regexp [string]
&rArr; function | (or null string)</p>

<p>Basic example:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">with-open-file</span></i> <span class="paren2">(<span class="code">out-file <span class="string">"out-file"</span> <span class="keyword">:direction</span> <span class="keyword">:output</span></span>)</span>
  <span class="paren2">(<span class="code">iter <span class="paren3">(<span class="code">for line in-file <span class="string">"in-file"</span> using #'readline</span>)</span>
        <span class="paren3">(<span class="code">and <span class="paren4">(<span class="code">m~ <span class="string">"(some)regexp(?&lt;with&gt;with)grouping(s)"</span> line</span>)</span>
             <span class="comment">;; plenty of anaphoric bindings are available after the match
</span>             <span class="paren4">(<span class="code">format out-file #?<span class="string">"$($1) $($2) $($with) $($3)"</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>First argument of M~ is read in with reader of #?r&ldquo; installed
for &rdquo;. Thus, you don&apos;t have to escape backslashes, appearing
in front of regexp-meaning characters.
Unfortunately, interpolation is not supported for now.
Only double quotes are chosen as a delimiter, as otherwise
 lisp-mode of Emacs would go crazy when seeing something like this: /&quot;/</p>

<p>When called with one argument (regexp), M~ expands into closure, which
accepts string. When called with same string repeatedly, it outputs
subsequent matches of the regexp on that string.</p>

<pre><code><span class="code">LOL-RE&gt; <span class="paren1">(<span class="code"><i><span class="symbol">defparameter</span></i> matcher <span class="paren2">(<span class="code">m~ <span class="string">"[a-z]"</span></span>)</span></span>)</span>
LOL-RE&gt; <span class="paren1">(<span class="code">funcall matcher <span class="string">"asdf"</span></span>)</span>
"a"
LOL-RE&gt; <span class="paren1">(<span class="code">funcall matcher <span class="string">"asdf"</span></span>)</span>
"s"
LOL-RE&gt; <span class="paren1">(<span class="code">funcall matcher <span class="string">"asdf"</span></span>)</span>
"d"
LOL-RE&gt; <span class="paren1">(<span class="code">funcall matcher <span class="string">"asdf"</span></span>)</span>
"f"
LOL-RE&gt; <span class="paren1">(<span class="code">funcall matcher <span class="string">"asdf"</span></span>)</span>
NIL</span></code></pre>

<p>When called with different strings, behavior may be strange.</p>

<pre><code><span class="code">LOL-RE&gt; <span class="paren1">(<span class="code"><i><span class="symbol">defparameter</span></i> matcher <span class="paren2">(<span class="code">m~ <span class="string">"[a-z]"</span></span>)</span></span>)</span>
LOL-RE&gt; <span class="paren1">(<span class="code">funcall matcher <span class="string">"foo"</span></span>)</span>
"f"
LOL-RE&gt; <span class="paren1">(<span class="code">funcall matcher <span class="string">"bar"</span></span>)</span> <span class="comment">; matching starts from the position, where first match finished
</span>"a"</span></code></pre>

<p>However, when called with :RESET keyword, the position counter inside the closure
is reset, so closure can be called now on some new string (see MR~ below).</p>

<pre><code><span class="code">LOL-RE&gt; <span class="paren1">(<span class="code"><i><span class="symbol">defparameter</span></i> matcher <span class="paren2">(<span class="code">m~ <span class="string">"[a-z]"</span></span>)</span></span>)</span>
LOL-RE&gt; <span class="paren1">(<span class="code">funcall matcher <span class="string">"foo"</span></span>)</span>
"f"
LOL-RE&gt; <span class="paren1">(<span class="code">funcall matcher <span class="keyword">:reset</span></span>)</span>
T
LOL-RE&gt; <span class="paren1">(<span class="code">funcall matcher <span class="string">"bar"</span></span>)</span>
"b"</span></code></pre>

<p>When called with two arguments (regexp and string), M~ expands into
application of a matching closure to that string, so the first match
of regexp on that string.</p>

<pre><code><span class="code">LOL-RE&gt; <span class="paren1">(<span class="code">m~ <span class="string">"[0-9]+"</span> <span class="string">"foo123bar456"</span></span>)</span>
"123"</span></code></pre>

<p>M~ also sets some anaphoric bindings (as seen in the basic example):
  * $0 is the whole match, $-0 and $+0 are the beginning and the end positions of whole match
  * $1 is the first group, $-1 and $+1 are the beginning and the end of the first group
  * &hellip; and so on for all other groups
  * if a group was <em>named</em>, say, &ldquo;foo&rdquo;, then also variables $FOO, $-FOO and $+FOO, with
    similar meaning. When generating symbol-name case of register is reversed, so
    for register named &ldquo;fOo&rdquo; symbols would be $|FoO|, $-|FoO| and $+|FoO|.</p>

<p>Since all those anaphoric bindings are (by default) global dynamic variables
  * they are equal to the ones relevant for the latest (in physical time) match performed.
  * this may be tricky when multithreading, but see RE-LOCAL macro below</p>

<h2>MR~</h2>

<p>Since M~ macro generates matcher-closure, which remembers position, from which to
perform the next match, it may behave strangely in seemingly obvious situations.</p>

<pre><code><span class="code">LOL-RE&gt; <span class="paren1">(<span class="code">dolist <span class="paren2">(<span class="code">elt '<span class="paren3">(<span class="code"><span class="string">"1"</span> <span class="string">"2"</span> <span class="string">"3"</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="code">format t <span class="string">"~a"</span> <span class="paren3">(<span class="code">m~ <span class="string">"[0-9]"</span> elt</span>)</span></span>)</span></span>)</span>
"1"
NIL
NIL</span></code></pre>

<p>This is because, after the first match, position remembered is already 1, and further
matches do not succeed.</p>

<p>This intuitive behavior is provided by MR~ macro (from &ldquo;match resettingly&rdquo;),
 which resets its position to 0, when performing each new match.</p>

<pre><code><span class="code">LOL-RE&gt; <span class="paren1">(<span class="code">dolist <span class="paren2">(<span class="code">elt '<span class="paren3">(<span class="code"><span class="string">"1"</span> <span class="string">"2"</span> <span class="string">"3"</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="code">format t <span class="string">"~a"</span> <span class="paren3">(<span class="code">mr~ <span class="string">"[0-9]"</span> elt</span>)</span></span>)</span></span>)</span>
"1"
"2"
"3"</span></code></pre>

<p>Of course, the most intuitive solution (and the most performance penalizing),
would be to maintain a hash of positions for each string being matched by the matcher,
generated by M~ macro. However, then the behavior in this example</p>

<pre><code><span class="code">LOL-RE&gt; <span class="paren1">(<span class="code">dolist <span class="paren2">(<span class="code">elt '<span class="paren3">(<span class="code"><span class="string">"a"</span> <span class="string">"a"</span> <span class="string">"a"</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="code">format t <span class="string">"~a"</span> <span class="paren3">(<span class="code">mr~ <span class="string">"[0-9]"</span> elt</span>)</span></span>)</span></span>)</span>
???</span></code></pre>

<p>would crucially depend on whether strings share structure, which may depend on details
of the compiler, which is even more obscuring, than current situation with two macro (M~ and MR~),
each of which behaves in the definite way.</p>

<h2>Iterate drivers</h2>

<p>System also defines two drivers for iterate: IN-MATCHES-OF and MATCHING</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">iter <span class="paren2">(<span class="code">for match in-matches-of <span class="string">"asdf"</span> using <span class="paren3">(<span class="code">m~ <span class="string">"[a-z]([a-z])"</span></span>)</span></span>)</span>
      <span class="paren2">(<span class="code">collect `<span class="paren3">(<span class="code">,match ,$0 ,$1</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><span class="paren2">(<span class="code"><span class="string">"as"</span> <span class="string">"as"</span> <span class="string">"s"</span></span>)</span> <span class="paren2">(<span class="code"><span class="string">"df"</span> <span class="string">"df"</span> <span class="string">"f"</span></span>)</span></span>)</span></span></code></pre>

<p>As seen from the example, IN-MATCHES-OF iterates over all
matches of given regexp in a given string. Both string and regexp
are evaluated once-only, in the initialization of the loop.</p>

<p>In contrast, first example could be rewritten using MATCHING driver as follows:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">with-open-file</span></i> <span class="paren2">(<span class="code">out-file <span class="string">"out-file"</span> <span class="keyword">:direction</span> <span class="keyword">:output</span></span>)</span>
  <span class="paren2">(<span class="code">iter <span class="paren3">(<span class="code">for line in-file <span class="string">"in-file"</span> using #'readline</span>)</span>
        <span class="paren3">(<span class="code">for match matching line using <span class="paren4">(<span class="code">m~ <span class="string">"(some)regexp(?&lt;with&gt;with)grouping(s)"</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">format out-file #?<span class="string">"$($1) $($2) $($with) $($3)"</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>but there are couple important things, which MATCHING does differently:
  * regexp is evaluated once-only, before the loop starts
  * even if the line didn&apos;t match regexp, FORMAT is still executed, printing line of NILs</p>

<p>So, MATCHING is more-or-less analogous to
<code>lisp
(let ((matcher (m~ &quot;(some)regexp(?&lt;with&gt;with)grouping(s)&quot;)))
  (with-open-file (out-file &quot;out-file&quot; :direction :output)
    (iter (for line in-file &quot;in-file&quot; using #'readline)
          (funcall matcher line)
          (format out-file #?&quot;$($1) $($2) $($with) $($3)&quot;))))
</code></p>

<p>TODO:
  * (done) creation of scanner, when regex-spec is just plain string
  * (wont do) do all the expansion at read-time, so that ((m~ &ldquo;asdf&rdquo;) str) syntax be possible
  * usage of cl-interpol strings as regex-spec
  * (done) list of strings instead of just one string (auto joining)
  * ability to turn off some anaphoric bindings
  * (done) convenient iterate macros
    * (done) for iterating over all matches within a given string
    * (done) for iterating over multiple strings with the same regexp
  * ability to use only #?r syntax on implementations not supported by CL-READ-MACRO-TOKENS</p>

<p>For more usage patterns, see tests.lisp file and use-cases.lisp.
use-cases.lisp was assembled by grepping of some quicklisp-available libs
and rewriting CL-PPCRE-using pieces with help of M~ and S~.</p>

<p>S~
&ndash;</p>

<p>For now, replacing only can replace first occurence of the match.
But, still, it&apos;s not needed to escape all those backslashes.</p>

<pre><code><span class="code">LOL-RE&gt; <span class="paren1">(<span class="code">s~ <span class="string">"(</span><span class="string">\d</span><span class="string">{4})-(</span><span class="string">\d</span><span class="string">{2})-(</span><span class="string">\d</span><span class="string">{2})"</span> <span class="string">"</span><span class="string">\3</span><span class="string">/</span><span class="string">\2</span><span class="string">/</span><span class="string">\1</span><span class="string">"</span> <span class="string">"2014-04-07"</span></span>)</span>
07/04/2014</span></code></pre>

<p>When called with just 2 arguments, generates replacer closure</p>

<pre><code><span class="code">LOL-RE&gt; <span class="paren1">(<span class="code">funcall <span class="paren2">(<span class="code">s~ <span class="string">"(</span><span class="string">\d</span><span class="string">{4})-(</span><span class="string">\d</span><span class="string">{2})-(</span><span class="string">\d</span><span class="string">{2})"</span> <span class="string">"</span><span class="string">\3</span><span class="string">/</span><span class="string">\2</span><span class="string">/</span><span class="string">\1</span><span class="string">"</span></span>)</span> <span class="string">"2014-04-07"</span></span>)</span>
07/04/2014</span></code></pre>

<p>TODO:
  * (done) creation of substituter, both target and replacement are plain strings, no named groups allowed
  * named groups are allowed in target
  * named groups are also allowed in replacement
  * cl-interpol #?r strings
  * lists are allowed instead of plain strings
  * G symbol switch to do all possible replacements</p>

<h2>re-local</h2>

<p>The purpose of this macro is to tackle issues, that arise when multithreading.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">re-local <span class="paren2">(<span class="code">all-the-variables like $1 $2 $a</span>)</span>
          <span class="paren2">(<span class="code">arising-from-use-of-m~</span>)</span>
          <span class="paren2">(<span class="code">are-declared-local-special</span>)</span>
          <span class="paren2">(<span class="code">inside-re-local</span>)</span></span>)</span></span></code></pre>

<p>So
<code>lisp
;; this is not thread-safe, as some other thread may corrupt $1 before PRINC gets executed
(and (m~ &quot;foo(bar)&quot;) (princ $1))
</code></p>

<p>But
<code>lisp
;; this is (supposedly) thread-safe, as all the relevant variables are implicitly
;; rebound as local dynamic, which are per-thread
(re-local (and (m~ &quot;foo(bar)&quot;) (princ $1)))
</code></p>

<p>How it works: codewalks (with help of HU.DWIM.WALKER) the body, with M~ and S~
redefined as MACROLETs, with same expansion, but with side-effect
of telling RE-LOCAL, what variables they are going to initialize.</p>

<p>N.B.: If M~ was to be defined fully as read-time macro,
 then it&apos;s not possible to write RE-LOCAL even using code-walking,
since it&apos;s not possible (read: very hard and ugly) to read the form twice from a stream.
So, I won&apos;t define M~ to be read-time macro, at cost of sometimes being required to write FUNCALL.</p>

<h2>Gotchas</h2>

<ul>
<li>potential racing conditions when multithreading (but, read re-local section)</li>
</ul>
