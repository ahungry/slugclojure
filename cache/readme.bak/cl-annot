<h1>cl-annot</h1>

<p>cl-annot is an general annotation library for Common Lisp.</p>

<p>cl-annot is tested under the following implementations:</p>

<ul>
<li>Allegro CL v8.2</li>
<li>SBCL v1.0.45</li>
<li>CMU CL v20b</li>
<li>Clozure CL v1.6</li>
<li>ECL v11.1.1</li>
<li>GNU CLISP v2.48</li>
</ul>

<h2>Overview</h2>

<p>Annotations is a special syntax for annotating and transforming
forms. Annotations look like Python&apos;s decorator:</p>

<pre><code>@annot
(defun foobar ()
  ...)
</code></pre>

<p>Any functions and macros can be annotations which takes one argument
by default. For example, if you define the following function,</p>

<pre><code>(defun trace (object)
  (print object)
  object)
</code></pre>

<p>you can use the function as an annotation like:</p>

<pre><code>@trace (+ 1 2)
</code></pre>

<p>This expression prints <code>3</code> and returns <code>3</code>. Internally, this
expression will be regarded as <code>(trace (+ 1 2))</code>.</p>

<p>Standard annotation <code>export</code> exports the symbol of the given
definition. For example,</p>

<pre><code>@export
(defun foobar ()
  ...)
</code></pre>

<p>defines a function <code>foobar</code> and exports the symbol <code>foobar</code>. This
equivalents to:</p>

<pre><code>(progn
  (export 'foobar)
  (defun foobar ()
    ...))
</code></pre>

<p>Annotations help you to write the simple and declarative codes.</p>

<h2>Usage</h2>

<p>Just write the following code at the header of each files:</p>

<pre><code>(annot:enable-annot-syntax)
</code></pre>

<p>After this code, <code>@...</code> syntax can be used.</p>

<h2>Emacs Configuration</h2>

<p>If you use Emacs, it is recommended to install <code>misc/slime-annot.el</code>
which contains some features of annotations. After locating
<code>misc/slime-annot.el</code> into your loadpath, write the following code
into your <code>.emacs</code>.</p>

<pre><code>(require 'slime-annot)
</code></pre>

<h2>Standard Annotations</h2>

<h3>Package: <code>annot.std</code></h3>

<p>This package contains very basic and useful annotations. You don&apos;t
need to <code>use-package</code> this package.</p>

<h4>Annotation: <code>export</code></h4>

<pre><code>@export DEFINITION-FORM
</code></pre>

<p><code>export</code> is a macro which adds an <code>export</code> form of the definition
form. For example,</p>

<pre><code>@export (defun f () ...)
</code></pre>

<p>is equivalent to</p>

<pre><code>(progn
  (export 'f)
  (defun f () ...))
</code></pre>

<h4>Annotation: <code>ignore</code></h4>

<pre><code>@ignore VARIABLES
</code></pre>

<p><code>ignore</code> is a macro which is equivalent to <code>(declare (ignore ...))</code>
form. For example,</p>

<pre><code>@ignore v
</code></pre>

<p>is equivalent to</p>

<pre><code>(declare (ignore v))
</code></pre>

<p><code>ignore</code> can take a list of variables like:</p>

<pre><code>@ignore (a b c)
</code></pre>

<h4>Annotation: <code>ignorable</code></h4>

<pre><code>@ignorable VARIABLES
</code></pre>

<p>Same as <code>ignore</code> annotation except that this is equivalent to</p>

<pre><code>(declare (ignorable v))
</code></pre>

<h4>Annotation: <code>type</code></h4>

<pre><code>@type TYPESPEC NAME
</code></pre>

<p><code>type</code> is a macro which is equivalent to <code>(declare (type ...))</code>
form. For example,</p>

<pre><code>@type integer v
</code></pre>

<p>is equivalent to</p>

<pre><code>(declare (type integer v))
</code></pre>

<h4>Annotation: <code>optimize</code></h4>

<pre><code>@optimize QUALITY
</code></pre>

<p><code>optimize</code> is a macro which is equivalent to <code>(declare (optimize
...))</code> form. For example,</p>

<pre><code>@optimize (speed 3)
</code></pre>

<p>is equivalent to</p>

<pre><code>(declare (optimize (speed 3)))
</code></pre>

<h4>Annotation: <code>inline</code></h4>

<pre><code>@inline NAME
</code></pre>

<p><code>inline</code> is a macro which is equivalent to <code>(proclaim (inline ...))</code>
or <code>(declare (inline ...))</code> form. If NAME is just a symbol,
declaration will be used. If NAME is a definition form, proclamation
will be used. For example,</p>

<pre><code>@inline f
</code></pre>

<p>is equivalent to</p>

<pre><code>(declare (inline f))
</code></pre>

<p>And</p>

<pre><code>@inline
(defun f () ...)
</code></pre>

<p>is equivalent to</p>

<pre><code>(proclam (inline f))
(defun f () ...)
</code></pre>

<h3>Package: <code>annot.eval-when</code></h3>

<p>This package contains annotations <code>eval-when</code> special form.</p>

<h4>Annotation: <code>eval-when-compile</code></h4>

<pre><code>@eval-when-compile FORM
</code></pre>

<p><code>eval-when-compile</code> is a macro which is equivalent to <code>(eval-when
(:compile-toplevel) ...)</code>. For example,</p>

<pre><code>@eval-when-compile
(defun macro-util () ...)
</code></pre>

<p>is equivalent to</p>

<pre><code>(eval-when-compile (:compile-toplevel)
  (defun macro-util () ...))
</code></pre>

<h4>Annotation: <code>eval-when-load</code></h4>

<pre><code>@eval-when-load FORM
</code></pre>

<p>Same as <code>eval-when-compile</code> except that this is equivalent to
<code>(eval-when (:load-toplevel) ...)</code>.</p>

<h4>Annotation: <code>eval-when-execute</code></h4>

<pre><code>@eval-when-execute FORM
</code></pre>

<p>Same as <code>eval-when-compile</code> except that this is equivalent to
<code>(eval-when (:execute) ...)</code>.</p>

<h4>Annotation: <code>eval-always</code></h4>

<pre><code>@eval-always FORM
</code></pre>

<p><code>eval-always</code> is a macro which is equivalent to <code>(eval-when
(:compile-toplevel :load-toplevel :execute) ...)</code>.</p>

<h3>Package: <code>annot.doc</code></h3>

<p>This package contains documentation annotations.</p>

<h4>Annotation: <code>doc</code></h4>

<pre><code>@doc DOCSTRING DEFINITION-FORM
</code></pre>

<p><code>doc</code> is a macro which inserts documentation string into the
definition form. For example,</p>

<pre><code>@doc &quot;docstring&quot;
(defun f () ...)
</code></pre>

<p>is equivalent to</p>

<pre><code>(defun f ()
  &quot;docstring&quot;
  ...)
</code></pre>

<p>Mixture of <code>export</code> annotation and <code>doc</code> annotation is allowed, means</p>

<pre><code>@export
@doc &quot;docstring&quot;
(defun f () ...)
</code></pre>

<p>works as you expected.</p>

<h3>Package: <code>annot.class</code></h3>

<p>This package contains annotations about classes.</p>

<h4>Annotation: <code>metaclass</code></h4>

<pre><code>@metaclass METACLASS CLASS-DEFINITION-FORM
</code></pre>

<p><code>metaclass</code> embeds <code>(:metaclsas METACLASS)</code> into class-options of
<code>CLASS-DEFINITION-FORM</code>. For example,</p>

<pre><code>@metaclass persistent-class
(defclass foo ()
     ())
</code></pre>

<p>is equivalent to</p>

<pre><code>(defclass foo ()
     ()
  (:metaclass persistent-class))
</code></pre>

<h4>Annotation: <code>export-slots</code></h4>

<pre><code>@export-slots CLASS-DEFINITION-FORM
</code></pre>

<p><code>export-slots</code> adds <code>(export ...)</code> form for slots of
<code>CLASS-DEFINITION-FORM</code>. For example,</p>

<pre><code>@export-slots
(defclass foo ()
     (bar baz))
</code></pre>

<p>is equivalent to</p>

<pre><code>(progn
  (export '(bar baz))
  (defclass foo ()
     (bar baz)))
</code></pre>

<p>It can also be used with <code>defstruct</code> as of the commit
<code>9043a74815a028a7db664f2fd77a8b009c736df9</code> (8/31,2013).</p>

<h4>Annotation: <code>export-accessors</code></h4>

<pre><code>@export-accessors CLASS-DEFINITION-FORM
</code></pre>

<p><code>export-accessors</code> adds <code>(export ...)</code> form for accessors
(i.e. readers, writers and accessors) of <code>CLASS-DEFINITION-FORM</code>. For
example,</p>

<pre><code>@export-accessors
(defclass foo ()
     ((bar :reader bar-of)
      (bax :writer bax-of)
      (baz :accessor baz-of)))
</code></pre>

<p>is equivalent to</p>

<pre><code>(progn
  (export '(bar-of bax-of baz-of))
  (defclass foo ()
     ((bar :reader bar-of)
      (bax :writer bax-of)
      (baz :accessor baz-of))))
</code></pre>

<p>It can also be used with <code>defstruct</code> as of the commit
<code>9043a74815a028a7db664f2fd77a8b009c736df9</code> (8/31,2013).</p>

<h4>Annotation: <code>export-constructors</code></h4>

<p>It can be used as of the commit
<code>9043a74815a028a7db664f2fd77a8b009c736df9</code> (8/31,2013).</p>

<p>According to the {CLHS: Macro
DEFSTRUCT}[http://www.lispworks.com/documentation/HyperSpec/Body/m_defstr.htm],
<code>defstruct</code> can define more than one constructor, for example:</p>

<pre><code>@export-constructors
(defstruct (s (:constructor abya a c)
              (:constructor abya2 a b c))
  a b c)
</code></pre>

<p>is equivalent to</p>

<pre><code>(progn
  (export '(abya abya2))
  (defstruct (s (:constructor abya a c)
                (:constructor abya2 a b c)) a b c))
</code></pre>

<p>and it might have no constructor like this.</p>

<pre><code>(defstruct (s (:constructor nil)) a b c)
</code></pre>

<h4>Annotation: <code>export-class</code> and <code>export-structure</code></h4>

<p><code>export-class</code> combines <code>export</code>, <code>export-slots</code> and
<code>export-accessors</code>. <code>export-structure</code> also combines
<code>export-constructors</code> in addition.</p>

<h3>Package: <code>annot.slot</code></h3>

<p>This package contains annotations about slots.</p>

<h4>Annotation: <code>optional</code></h4>

<pre><code>@optional INITFORM SLOT-SPECIFIER
</code></pre>

<p><code>optional</code> embeds <code>:initarg SLOT-NAME</code> and <code>:initform INITFORM</code> into
<code>SLOT-SPECIFIER</code>. For example,</p>

<pre><code>(defclass c ()
     (@optional nil
      foo))
</code></pre>

<p>is equivalent to</p>

<pre><code>(defclass c ()
     ((foo :initarg :foo
           :initform nil)))
</code></pre>

<h4>Annotation: <code>required</code></h4>

<pre><code>@required SLOT-SPECIFIER
</code></pre>

<p><code>required</code> embeds <code>:initarg SLOT-NAME</code> and <code>:initform
(annot.slot:required-argument SLOT-NAME)</code> into <code>SLOT-SPECIFIER</code> so
that <code>MAKE-INSTANCE</code> will raise errors when no argument for the slot
given. For example,</p>

<pre><code>(defclass c ()
     (@required
      foo))
</code></pre>

<p>is equivalent to</p>

<pre><code>(defclass c ()
     ((foo :initarg :foo
           :initform (annot.slot:required-argument :foo))))
</code></pre>

<h2>Writing Annotations</h2>

<p>As I mentioned, any functions and macros can be
annotations. Basically, if you have a function or a macro named
<code>annot</code>, the following code</p>

<pre><code>@annot (+ 1 2)
</code></pre>

<p>will be expanded like</p>

<pre><code>(annot (+ 1 2))
</code></pre>

<h3>Aliasing</h3>

<p>You may use an alias for specifying annotations. This is useful when
you want to use more general names as annotation names. Actually,
<code>annot.std</code> uses this technique to overriding the meanings of symbols
in <code>common-lisp</code> package. Here is how to alias:</p>

<pre><code>(setf (annotation-real 'do) 'long-long-name)
</code></pre>

<p>Now you can use <code>do</code> as meaning <code>long-long-name</code> at annotations like:</p>

<pre><code>@do ...
</code></pre>

<h3>Multiple Arguments</h3>

<p>By default, annotations can take only one argument. If you want to
write an annotation taking two or more arguments, you need to specify
a number of arguments into the annotation symbol like:</p>

<pre><code>(use-package :annot.core)

(defun my-annot (x y) (+ x y))
(setf (annotation-arity 'my-annot) 2)
</code></pre>

<p>Now you can use this annotation like:</p>

<pre><code>@my-annot 2 3
;; =&gt; 5
</code></pre>

<h3>Inlining</h3>

<p>In some cases, you want annotations to be expanded at read-time. You can do it by:</p>

<pre><code>(setf (annotation-inline-p 'annot) t)
</code></pre>

<p>Be caseful to use feature.</p>

<h3>Macro: <code>defannotation</code></h3>

<pre><code>defannotation NAME LAMBDA-LIST (:alias ALIAS :arity ARITY :inline INLINE) &amp;body BODY
</code></pre>

<p><code>defannotation</code> is an utility macro for creating annotations. Here is an example:</p>

<pre><code>(defannotation my-annot (x y)
    (:arity 2 :inline t)
  `(+ ,x ,y))
</code></pre>

<h3>Annotation: <code>annotation</code></h3>

<pre><code>annotation (:alias ALIAS :arity ARITY :inline INLINE) FUNCTION-DEFINITION-FORM
</code></pre>

<p><code>annotation</code> is an annotation for creating annotations in a way of
<code>defannotation</code>. Here is an example:</p>

<pre><code>@annotation (:arity 2 :inline t)
(defmacro my-annot (x y)
  `(+ ,x ,y))
</code></pre>

<hr/>

<p>Copyright (C) 2011  Tomohiro Matsuyama &lt;<a href="m&#x61;&#105;l&#x74;&#111;:&#x74;&#111;m&#x6F;&#64;c&#x78;&#52;a&#x2E;&#111;r&#x67;">m&#x61;&#105;l&#x74;&#111;:&#x74;&#111;m&#x6F;&#64;c&#x78;&#52;a&#x2E;&#111;r&#x67;</a>&gt;</p>
