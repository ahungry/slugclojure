<h1>Websocket Driver</h1>

<p>This library provides a complete implementation of the WebSocket protocols.</p>

<h2>Usage</h2>

<h3>Server-side with Clack</h3>

<pre><code><span class="code"><span class="paren1">(<span class="code">ql:quickload '<span class="paren2">(<span class="code"><span class="keyword">:websocket-driver</span> <span class="keyword">:clack</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code">use-package <span class="keyword">:websocket-driver</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defvar</span></i> <span class="special">*echo-server*</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="code">env</span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">ws <span class="paren6">(<span class="code">make-server env</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">on <span class="keyword">:message</span> ws
          <span class="paren5">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren6">(<span class="code">ev</span>)</span>
            <span class="paren6">(<span class="code">send ws <span class="paren1">(<span class="code">event-data ev</span>)</span></span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="code">responder</span>)</span>
        <span class="paren5">(<span class="code">declare <span class="paren6">(<span class="code">ignore responder</span>)</span></span>)</span>
        <span class="paren5">(<span class="code">start-connection ws</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code">clack:clackup <span class="special">*echo-server*</span> <span class="keyword">:server</span> <span class="keyword">:wookie</span> <span class="keyword">:port</span> 5000</span>)</span></span></code></pre>

<h3>Server-side with Wookie</h3>

<pre><code><span class="code"><span class="paren1">(<span class="code">ql:quickload '<span class="paren2">(<span class="code"><span class="keyword">:websocket-driver</span> <span class="keyword">:wookie</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code">use-package '<span class="paren2">(<span class="code"><span class="keyword">:wookie</span> <span class="keyword">:websocket-driver</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defroute</span></i> <span class="paren2">(<span class="code"><span class="keyword">:get</span> <span class="string">"/echo"</span> <span class="keyword">:chunk</span> nil</span>)</span> <span class="paren2">(<span class="code">req res</span>)</span>
  <span class="paren2">(<span class="code">declare <span class="paren3">(<span class="code">ignore res</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">ws <span class="paren5">(<span class="code">make-server req <span class="keyword">:type</span> <span class="keyword">:wookie</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">on <span class="keyword">:message</span> ws
        <span class="paren4">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="code">event</span>)</span>
          <span class="paren5">(<span class="code">send ws <span class="paren6">(<span class="code">event-data event</span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">start-connection ws</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">as:with-event-loop</span></i> <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">start-server <span class="paren3">(<span class="code">make-instance 'listener <span class="keyword">:port</span> 5000</span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>Client-side</h3>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defvar</span></i> <span class="special">*client*</span> <span class="paren2">(<span class="code">wsd:make-client <span class="string">"ws://localhost:5000/echo"</span></span>)</span></span>)</span></span></code></pre>

<h2>Driver API</h2>

<h4><code>(on :open driver callback)</code></h4>

<p>Sets the <code>CALLBACK</code> function to execute when the socket becomes open.</p>

<h4><code>(on :message driver callback)</code></h4>

<p>Sets the <code>CALLBACK</code> to execute when a message is received. The <code>CALLBACK</code> function takes a <code>MESSAGE-EVENT</code> as an argument which has an accessor <code>EVENT-DATA</code> to get the data that is either a string in the case of a text message or an <code>(UNSIGNED-BYTE 8)</code> vector in the case of a binary message.</p>

<h4><code>(on :error driver callback)</code></h4>

<p>Sets the <code>CALLBACK</code> to execute when a protocol error occurs due to the other peer sending an invalid byte sequence. The <code>CALLBACK</code> function takes a <code>PROTOCOL-ERROR</code> as an argument.</p>

<h4><code>(on :close driver callback)</code></h4>

<p>Sets the <code>CALLBACK</code> to execute when the socket becomes closed. The <code>CALLBACK</code> function takes a <code>CLOSE-EVENT</code> as an argument which has accessors <code>EVENT-CODE</code> and <code>EVENT-REASON</code>.</p>

<h4><code>(start-connection driver)</code></h4>

<p>Initiates the protocol by sending the handshake - either the response for a server-side driver or the request for a client-side one. This should be the first method you invoke. Returns <code>T</code> if a handshake was sent.</p>

<h4><code>(parse driver data)</code></h4>

<p>Takes <code>DATA</code> and parses it, potentially resulting in message events being emitted (see <code>(on :message ...)</code> above). You should send all data you receive via I/O to this method.</p>

<h4><code>(send driver data &amp;key type code)</code></h4>

<p>Sends <code>DATA</code> over the socket.</p>

<h4><code>(send-text driver string)</code></h4>

<p>Sends a text message over the socket.</p>

<h4><code>(send-binary driver usb8-vector)</code></h4>

<p>Takes an <code>(UNSIGNED-BYTE 8)</code> vector and sends them as a binary message.</p>

<h4><code>(send-ping driver &amp;optional message callback)</code></h4>

<p>Sends a ping frame over the socket, queueing it if necessary.</p>

<h4><code>(close-connection driver)</code></h4>

<p>Initiates the closing handshake if the socket is still open.</p>

<h4><code>(version driver)</code></h4>

<p>Returns the WebSocket version in use as a string.</p>

<h4><code>(protocol driver)</code></h4>

<p>Returns a string containing the selected subprotocol, if any was agreed upon using the <code>Sec-WebSocket-Protocol</code> mechanism.</p>

<h2>Author</h2>

<ul>
<li>Eitaro Fukamachi (e.arrows@gmail.com)</li>
</ul>

<h2>Copyright</h2>

<p>Copyright (c) 2014 Eitaro Fukamachi (e.arrows@gmail.com)</p>

<h2>License</h2>

<p>Licensed under the BSD 2-Clause License.</p>

<h2>See Also</h2>

<ul>
<li><a href="https://github.com/fukamachi/event-emitter" >Event Emitter</a></li>
</ul>
