<h1>Cheat-JS - macros for JavaScript. Kinda.</h1>

<p>This document assumes you already know Common Lisp and JavaScript.</p>

<h2>About Cheat-JS</h2>

<p>Lisp macros are powerful and easy to implement because Lisp programs
are made of s-expressions.</p>

<p>Lisp-style macros are difficult to add to other languages because most
languages have very non-uniform syntax compared to Lisp. Source
transformations (and most importantly macros) would be easier in, say,
JavaScript, if it were possible to convert the JavaScript code into
s-expressions, transform it, and convert it back into JavaScript code.</p>

<p>Turns out that we can transform JavaScript code into an AST made of
s-expressions using
<a href="http://marijnhaverbeke.nl/parse-js/" ><code>parse-js</code></a>. Converting back
into JavaScript code can be done with
<a href="https://github.com/mishoo/cl-uglify-js" ><code>cl-uglify-js</code></a> (ironically,
<code>cl-uglify-js:ast-gen-code</code> is a capable pretty printer). All that
remains to be done to have macros (well, defined in another language)
is define transformations to be applied on the output of
<code>parse-js</code>. This is what Cheat-JS does: get the <code>parse-js</code> AST, apply
the transformations, convert back to JavaScript code.</p>

<p>The idea is rather obvious - the main reason Cheat-JS exists is that I
could not find something similar on the net. There are probably many
people who privately do similar things with tools like <code>parse-js</code> and
the pretty-printer part of <code>cl-uglify-js</code> - that, or my Google skills
failed me :)</p>

<h3>Important Note</h3>

<p>Cheat-JS includes a modified version of <code>parse-js</code>, written by Marijn
Haverbeke. This is necessary because I (Miron Brezuleanu) needed to
modify <code>parse-js</code> a little. The license of <code>parse-js</code> is in the
<code>LICENSE-parse-js.txt</code> file. The modified files from <code>parse-js</code>
included in Cheat-JS are <code>parse.lisp</code>, <code>tokenize.lisp</code> and
<code>util.lisp</code>. The modifications were permitted by the <code>parse-js</code>
license. This is not an official copy of <code>parse-js</code> and is not
supported by Marijn Haverbeke. If the modified parsing code in
Cheat-JS breaks, it&apos;s exclusively my fault - I messed up the code.</p>

<p>Cheat-JS also uses <code>cl-uglify-js</code> unmodified, via
<a href="http://www.quicklisp.org/" >Quicklisp</a>. These two libraries do most of
the work, Cheat-JS is mostly &lsquo;glue code&rsquo;.</p>

<h3>BIG WARNING</h3>

<p>I haven&apos;t used Cheat-JS on any large projects. I don&apos;t have enough
imagination to compensate for this lack of experience, so it may have
a lot of problems I haven&apos;t thought about. Right now it&apos;s just a proof
of concept.</p>

<h2>Some simple examples</h2>

<p>Instead of writing:</p>

<pre><code>var Person = function(name, shoeSize) {
    this.name = name;
    this.shoeSize = shoeSize;
};
</code></pre>

<p>Cheat-JS makes it possible to write:</p>

<pre><code>var Person = @defclass(name, shoeSize);
</code></pre>

<p>(Some irregularities in JavaScript syntax make it much harder to
expand something like <code>@defclass(Person, name, shoeSize);</code> into
<code>function Person(name, shoeSize) { this.name = name; this.shoeSize =
shoeSize; };</code>).</p>

<p>This assumes that we have defined a <code>@defclass</code> macro which does the
above expansion - we&apos;ll define two such macros in this document.</p>

<p>One of the <code>parse-js</code> modifications necessary for this to work is
allow <code>@</code> as a character in identifiers (the Cheat-JS recommended
convention for naming macros is <code>@</code> followed by the macro
name). Currently macro names can&apos;t be nested
(i.e. <code>some.namespace.@iife</code> is not valid syntax).</p>

<p>Instead of writing:</p>

<pre><code>var greeter = (function () {
    return {
        'hello': function(name) {
            console.log('hello, '+ name);
        };
    };
}());
</code></pre>

<p>Cheat-JS makes it possible to write:</p>

<pre><code>var greeter = @iife(
    return {
        'hello': function(name) {
            console.log('hello, '+ name);
        }
    };
);
</code></pre>

<p>This assumes that we have defined a <code>@iife</code> macro that wraps its
arguments with <code>(function () { ... }())</code>
(<a href="http://www.benalman.com/news/2010/11/immediately-invoked-function-expression/" >meaning of the IIFE acronym</a>).</p>

<p>I also had to modify <code>parse-js</code> to convince it to parse macro
invocations that look like function calls, but have a list of
statements instead of a list of parameters (see the invocation of
<code>@iife</code> above).</p>

<p>Instead of writing:</p>

<pre><code>(function () {
    var testResult = someTest();
    if (testResult) {
        console.log(&quot;Yes!&quot;);
        console.log(&quot;We passed the test with result &quot;, testResult, &quot;.&quot;);
    }
})();
</code></pre>

<p>Cheat-JS makes it possible to write:</p>

<pre><code>@whenLet(testResult, someTest();
    console.log(&quot;Yes!&quot;);
    console.log(&quot;We passed the test with result &quot;, testResult, &quot;.&quot;);
);
</code></pre>

<p>This macro is similar to
<a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Data-and-Control-Flow" ><code>alexandria:when-let</code></a>. <code>@whenLet</code>
has the most complicated interface possible for a Cheat-JS macro: its
argument list has both expressions (<code>testResult</code>, <code>someTest()</code>) and
statements (the <code>console.log</code> call). When invoking such macros,
separate the expressions and the statements with a semicolon, as in
the example above.</p>

<p>It is of course possible to define the anaphoric version of
<code>@whenLet</code>, <code>@awhen</code> (from
<a href="http://paulgraham.com/onlisp.html" >On Lisp</a>, page 190).</p>

<p>The guide on how to write Cheat-JS macros (below in this document) is
based on defining <code>@defclass</code> (and even a safer version of
<code>@defclass</code>), <code>@iife</code>, <code>@whenLet</code> and <code>@awhen</code>.</p>

<h2>Getting started</h2>

<p>You can get Cheat-JS at <code>http://github.com/mbrezu/cheat-js</code>. It&apos;s
probably best to <code>git clone</code> it inside the <code>local-projects</code> directory
of your Quicklisp install, so you can load it with <code>(ql:quickload
:cheat-js)</code> in your REPL.</p>

<p>Note: I&apos;ve only tested it with SBCL, so I recommend you use SBCL
too. It should work with other CL implementations, though (all the
code required is standard CL).</p>

<p>Running the tests with:</p>

<pre><code>(cheat-js:run-tests)
</code></pre>

<p>gives some confidence that things are not obviously broken (they are
most likely broken, but in ways that are subtle enough to fool the
tests).</p>

<p>The next section will provide you with some pointers on how to define
your Cheat-JS macros. If you run into problems, look at the
<code>tests.lisp</code> file for example code - the code there matches the text
in the next section.</p>

<h2>Your first Cheat-JS macros</h2>

<p>Before running the macroexpansion function <code>cheat-js:explode</code> on your
JavaScript source code, you need to install your macros.</p>

<p>First reset the list of installed macros:</p>

<pre><code>&gt; (cheat-js:clear-macros)
</code></pre>

<p>To define a macro, you need to know three things:</p>

<ul>
<li>how the macro invocation call looks like (what you want to write in
   the JavaScript source code); this is the macro&apos;s &ldquo;API&rdquo;; it is
   JavaScript code (or almost);</li>
<li>how the macro expansion looks like in JavaScript; this is the
   macro&apos;s &ldquo;result&rdquo;;</li>
<li>how to transform the AST of the invocation into the AST of the
   expansion; this is the macro&apos;s &ldquo;implementation&rdquo;, written in Common
   Lisp.</li>
</ul>

<p>Let&apos;s define <code>@defclass</code>.</p>

<h3>Defining <code>@defclass</code></h3>

<p>We need to see how the macro invocation looks like in JavaScript:</p>

<pre><code>var Person = @defclass(name, shoeSize)
</code></pre>

<p>We can tell that the macro is an &lsquo;args only&rsquo; macro (i.e. the
invocation looks like a normal JavaScript function invocation, it does
not contains statements). We can inform Cheat-JS about this:</p>

<pre><code>&gt; (cheat-js:register-args-macro &quot;@defclass&quot;)
</code></pre>

<p>We also want to see the AST for the invocation (we use Cheat-JS&apos;s
parsing function because the above snippet is not parsable by
<code>parse-js</code> without tweaks; in particular, the parsing won&apos;t work as
expected if we don&apos;t call <code>register-args-macro</code> as above, so don&apos;t
skip that step):</p>

<pre><code>&gt; (cheat-js:parse-js &quot;var Person = @defclass(name, shoeSize);&quot;)
(:TOPLEVEL
 ((:VAR
   ((&quot;Person&quot; :MACRO-CALL (:NAME &quot;@defclass&quot;)
     (:ARGS (:NAME &quot;name&quot;) (:NAME &quot;shoeSize&quot;)))))))
</code></pre>

<p>The part that starts with <code>:MACRO-CALL</code> is the interesting part; this
is the AST representation of our macro invocation; this is what we
need to transform into the expansion (don&apos;t worry about the apparently
missing <code>(</code> in front of <code>:MACRO-CALL</code> above, it&apos;s because the list
following <code>:VAR</code> is made of conses, not lists).</p>

<p>What does the expansion look like? Let&apos;s see:</p>

<pre><code>&gt; (cheat-js:parse-js &quot;var Person = function(name, shoeSize)
                      {
                          this.name = name;
                          this.shoeSize = shoeSize;
                      };&quot;)

(:TOPLEVEL
 ((:VAR
   ((&quot;Person&quot; :FUNCTION NIL (&quot;name&quot; &quot;shoeSize&quot;)
     ((:STAT (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;name&quot;) (:NAME &quot;name&quot;)))
      (:STAT
       (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;shoeSize&quot;) (:NAME &quot;shoeSize&quot;)))))))))
</code></pre>

<p>Comparing the two ASTs reveals that we need to transform the
<code>(:MACRO-CALL</code> s-expression into the <code>(:FUNCTION</code> s-expression.</p>

<p>To make it clearer, we need to write a Common Lisp function to transform this:</p>

<pre><code>(:MACRO-CALL (:NAME &quot;@defclass&quot;)
 (:ARGS (:NAME &quot;name&quot;) (:NAME &quot;shoeSize&quot;)))
</code></pre>

<p>into this:</p>

<pre><code>(:FUNCTION NIL (&quot;name&quot; &quot;shoeSize&quot;)
 ((:STAT (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;name&quot;) (:NAME &quot;name&quot;)))
  (:STAT (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;shoeSize&quot;) (:NAME &quot;shoeSize&quot;)))))
</code></pre>

<p>We only need the macro arguments to perform the expansion. Since we
told Cheat-JS this is an &lsquo;args only&rsquo; macro, it knows we&apos;re only
interested in the arguments (not the entire <code>:MACRO-CALL</code> tree), so
that&apos;s what it will pass to our expander function:</p>

<pre><code>&gt; (defun defclass-expander (args)
    (let* ((names (mapcar #'second args)))
      `(:function nil ,names
                  ,(mapcar (lambda (name)
                             `(:stat
                               (:assign t
                                        (:dot (:name &quot;this&quot;) ,name)
                                        (:name ,name))))
                           names))))
</code></pre>

<p>The parameter <code>args</code> contains the list of arguments extracted from
<code>(:ARGS...</code> above (in our case <code>((:NAME &quot;name&quot;) (:NAME
&quot;shoeSize&quot;))</code>). The value returned by the function should be the
expansion shown above (s-expression starting with <code>(:FUNCTION...</code>).</p>

<p>Let&apos;s test it:</p>

<pre><code>&gt; (let ((args '((:NAME &quot;name&quot;) (:NAME &quot;shoeSize&quot;))))
    (defclass-expander args))
(:FUNCTION NIL (&quot;name&quot; &quot;shoeSize&quot;)
           ((:STAT (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;name&quot;) (:NAME &quot;name&quot;)))
            (:STAT (:ASSIGN T
                            (:DOT (:NAME &quot;this&quot;) &quot;shoeSize&quot;)
                            (:NAME &quot;shoeSize&quot;)))))
</code></pre>

<p>Looks OK. Let&apos;s tell Cheat-JS about our function:</p>

<pre><code>&gt; (cheat-js:register-macro-expander &quot;@defclass&quot; #'defclass-expander)
</code></pre>

<p>Now we can ask Cheat-JS to macroexpand our code:</p>

<pre><code>&gt; (cheat-js:explode &quot;var Person = @defclass(name, shoeSize);&quot;)
&quot;var Person = function(name, shoeSize)
{
    this.name = name;
    this.shoeSize = shoeSize;
};&quot;
</code></pre>

<p><code>cl-uglify-js</code> is a really good pretty printer, isn&apos;t it?</p>

<p>On to <code>@iife</code>.</p>

<h3>Defining <code>@iife</code></h3>

<p>Again, we&apos;ll see the invocation (both JavaScript and <code>parse-js</code> AST),
expansion and implementation for the macro.</p>

<p>Let&apos;s recall the JavaScript for the invocation from the examples
above:</p>

<pre><code>var greeter = @iife(
    return {
        'hello': function(name) {
            console.log('hello, '+ name);
        }
    };
);
</code></pre>

<p>This is a &lsquo;body&rsquo; macro - its only argument is a list of JavaScript
statements. Let&apos;s tell Cheat-JS:</p>

<pre><code>&gt; (cheat-js:register-body-macro &quot;@iife&quot;)
</code></pre>

<p>We can now ask the parser for the invocation AST. We&apos;ll work with a
simplified invocation, though - the example above will generate a
large AST, and we can just as well manage with a smaller one. It&apos;s
also better if our invocation has more than one statement, so let&apos;s
try this:</p>

<pre><code>&gt; (cheat-js:parse-js &quot;var a = @iife(alert(1); return 1;);&quot;)
(:TOPLEVEL
 ((:VAR
   ((&quot;a&quot; :MACRO-CALL (:NAME &quot;@iife&quot;)
     (:BODY (:STAT (:CALL (:NAME &quot;alert&quot;) ((:NUM 1))))
            (:RETURN (:NUM 1))))))))
</code></pre>

<p>The expansion we desire for this invocation:</p>

<pre><code>&gt; (cheat-js:parse-js &quot;var a = (function() { alert(1); return 1; })();&quot;)
(:TOPLEVEL
 ((:VAR
   ((&quot;a&quot; :CALL
     (:FUNCTION NIL NIL
      ((:STAT (:CALL (:NAME &quot;alert&quot;) ((:NUM 1)))) (:RETURN (:NUM 1))))
     NIL)))))
</code></pre>

<p>OK. We need to expand:</p>

<pre><code>(:MACRO-CALL (:NAME &quot;@iife&quot;)
  (:BODY (:STAT (:CALL (:NAME &quot;alert&quot;) ((:NUM 1))))
         (:RETURN (:NUM 1))))
</code></pre>

<p>into:</p>

<pre><code>(:CALL (:FUNCTION NIL NIL
         ((:STAT (:CALL (:NAME &quot;alert&quot;) ((:NUM 1))))
          (:RETURN (:NUM 1))))
       NIL)
</code></pre>

<p>The function to do this is:</p>

<pre><code>(defun iife-expander (body)
  `(:CALL (:FUNCTION NIL NIL ,body)
          NIL))
</code></pre>

<p>Since we told Cheat-JS this is a &lsquo;body only&rsquo; macro, it extracts the
body from the <code>:MACRO-CALL</code> AST and passes it to our expander.</p>

<p>A quick test:</p>

<pre><code>&gt; (let ((body '((:STAT (:CALL (:NAME &quot;alert&quot;) ((:NUM 1))))
                (:RETURN (:NUM 1)))))
    (iife-expander body))
(:CALL
 (:FUNCTION NIL NIL
            ((:STAT (:CALL (:NAME &quot;alert&quot;) ((:NUM 1))))
             (:RETURN (:NUM 1))))
 NIL)
</code></pre>

<p>Looks OK. Let&apos;s install it:</p>

<pre><code>&gt; (cheat-js:register-macro-expander &quot;@iife&quot; #'iife-expander)
</code></pre>

<p>Let&apos;s use it:</p>

<pre><code>&gt; (cheat-js:explode &quot;var a = @iife(alert(1); return 1;);&quot;)
&quot;var a = function() {
    alert(1);
    return 1;
}();&quot;
</code></pre>

<p>Oops. Some parens got dropped. This is not really an issue, the
resulting JavaScript is still valid. Let&apos;s try another example:</p>

<pre><code>&gt; (cheat-js:explode &quot;@iife(alert(1); return 1;);&quot;)
&quot;(function() {
    alert(1);
    return 1;
})();&quot;
</code></pre>

<p>Good! The parens were required this time, and they are there.</p>

<p>Now that we have <code>@iife</code> we can write a safer <code>@defclass</code> (and also
see an example of combining Cheat-JS macros).</p>

<h3>Defining a safer <code>@defclass</code></h3>

<p>We used the following Javascript &lsquo;class definition&rsquo; for the
<code>@defclass</code> example:</p>

<pre><code>var Person = function(name, shoeSize)
{
    this.name = name;
    this.shoeSize = shoeSize;
};
</code></pre>

<p>This code has a well-known problem. To create a <code>Person</code> object, one
should use a call like <code>new Person('John', 42);</code>. If we forget the
<code>new</code> keyword, we are in trouble, because <code>this</code> inside the function
no longer refers to a newly created object, but to <code>window</code>, the
global object.</p>

<p>Isn&apos;t there a way around this? Let&apos;s try to define <code>Person</code> like this:</p>

<pre><code>var Person = (function () {
    function Person(name, shoeSize) {
        this.name = name;
        this.shoeSize = shoeSize;
    }
    return function (name, shoeSize) {
        return new Person(name, shoeSize);
    };
}());
</code></pre>

<p>Now it doesn&apos;t matter if we use <code>new</code> or we leave it out. A new
<code>Person</code> object is always returned. The new definition is a bit
verbose, though. Maybe we can use&hellip; a macro?</p>

<p>Let&apos;s examine the three pieces of data we need for a new macro. The
invocation in JavaScript:</p>

<pre><code>var Person = @safeDefclass(Person, name, shoeSize);
</code></pre>

<p>This is certainly more like it, conciseness-wise.</p>

<p><code>@safeDefclass</code>, like <code>@defclass</code>, is an &apos;args only` macro:</p>

<pre><code>&gt; (cheat-js:register-args-macro &quot;@safeDefclass&quot;)
</code></pre>

<p>The AST of the invocation:</p>

<pre><code>&gt; (cheat-js:parse-js &quot;var Person = @safeDefclass(Person, name, shoeSize);&quot;)
(:TOPLEVEL
 ((:VAR
   ((&quot;Person&quot; :MACRO-CALL (:NAME &quot;@safeDefclass&quot;)
     (:ARGS (:NAME &quot;Person&quot;) (:NAME &quot;name&quot;) (:NAME &quot;shoeSize&quot;)))))))
</code></pre>

<p>What about the expansion? Do we want the expansion shown above, or is
it possible to expand to something shorter? This is a macro-combining
opportunity, let&apos;s not waste it. The expansion is:</p>

<pre><code>var Person = @iife(
    function Person(name, shoeSize) {
        this.name = name;
        this.shoeSize = shoeSize;
    };
    return function (name, shoeSize) {
        return new Person(name, shoeSize);
    };
);
</code></pre>

<p>If your REPL was restarted after defining <code>@iife</code>, please reinstall
<code>@iife</code> in the new REPL by using the instructions in the last section
(or the code in <code>tests.lisp</code>).</p>

<p>Now we can ask <code>cheat-js</code> about the AST of the expansion:</p>

<pre><code>&gt; (cheat-js:parse-js &quot;var Person = @iife(
                          function Person(name, shoeSize) {
                              this.name = name;
                              this.shoeSize = shoeSize;
                          };
                          return function (name, shoeSize) {
                              return new Person(name, shoeSize);
                          };
                      );&quot;)
(:TOPLEVEL
 ((:VAR
   ((&quot;Person&quot; :MACRO-CALL (:NAME &quot;@iife&quot;)
     (:BODY
      (:DEFUN &quot;Person&quot; (&quot;name&quot; &quot;shoeSize&quot;)
       ((:STAT (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;name&quot;) (:NAME &quot;name&quot;)))
        (:STAT
         (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;shoeSize&quot;) (:NAME &quot;shoeSize&quot;)))))
      (:BLOCK NIL)
      (:RETURN
       (:FUNCTION NIL (&quot;name&quot; &quot;shoeSize&quot;)
        ((:RETURN
          (:NEW (:NAME &quot;Person&quot;) ((:NAME &quot;name&quot;) (:NAME &quot;shoeSize&quot;)))))))))))))
</code></pre>

<p>So our <code>:MACRO-CALL</code> expands into a new <code>:MACRO-CALL</code>. Cheat-JS should
be able to handle this, like a good little macroexpander.</p>

<p>To make writing the expansion function easier, let&apos;s isolate the
source and target ASTs. The invocation:</p>

<pre><code>(:MACRO-CALL (:NAME &quot;@safeDefclass&quot;)
 (:ARGS (:NAME &quot;Person&quot;) (:NAME &quot;name&quot;) (:NAME &quot;shoeSize&quot;)))
</code></pre>

<p>and our desired expansion:</p>

<pre><code>(:MACRO-CALL (:NAME &quot;@iife&quot;)
 (:BODY
  (:DEFUN &quot;Person&quot; (&quot;name&quot; &quot;shoeSize&quot;)
   ((:STAT (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;name&quot;) (:NAME &quot;name&quot;)))
    (:STAT (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;shoeSize&quot;) (:NAME &quot;shoeSize&quot;)))))
  (:BLOCK NIL)
  (:RETURN
   (:FUNCTION NIL (&quot;name&quot; &quot;shoeSize&quot;)
    ((:RETURN (:NEW (:NAME &quot;Person&quot;) ((:NAME &quot;name&quot;)
                                      (:NAME &quot;shoeSize&quot;)))))))))
</code></pre>

<p>The expander function:</p>

<pre><code>(defun safe-defclass-expander (args)
  (let* ((names (mapcar #'second args))
         (class-name (first names))
         (field-names (rest names)))
    `(:MACRO-CALL
      (:NAME &quot;@iife&quot;)
      (:BODY
       (:DEFUN ,class-name ,field-names
         ,(mapcar (lambda (field)
                    `(:STAT (:ASSIGN T
                                     (:DOT (:NAME &quot;this&quot;) ,field)
                                     (:NAME ,field))))
                  field-names))
       (:BLOCK NIL)
       (:RETURN
         (:FUNCTION NIL ,field-names
                    ((:RETURN (:NEW (:NAME ,class-name)
                                    ,(mapcar (lambda (field)
                                               (list :name field))
                                             field-names))))))))))
</code></pre>

<p>Test the expander function:</p>

<pre><code>&gt; (let* ((args '((:NAME &quot;Person&quot;)
                 (:NAME &quot;name&quot;)
                 (:NAME &quot;shoeSize&quot;))))
    (safe-defclass-expander args))
(:MACRO-CALL (:NAME &quot;@iife&quot;)
 (:BODY
  (:DEFUN &quot;Person&quot; (&quot;name&quot; &quot;shoeSize&quot;)
   ((:STAT (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;name&quot;)
                    (:NAME &quot;name&quot;)))
    (:STAT (:ASSIGN T (:DOT (:NAME &quot;this&quot;) &quot;shoeSize&quot;)
                    (:NAME &quot;shoeSize&quot;)))))
  (:BLOCK NIL)
  (:RETURN
   (:FUNCTION NIL (&quot;name&quot; &quot;shoeSize&quot;)
    ((:RETURN (:NEW (:NAME &quot;Person&quot;) ((:NAME &quot;name&quot;)
                                      (:NAME &quot;shoeSize&quot;)))))))))
</code></pre>

<p>It seems to do what we want. Let&apos;s install and test it:</p>

<pre><code>&gt; (cheat-js:register-macro-expander &quot;@safeDefclass&quot;
                                    #'safe-defclass-expander)
&gt; (cheat-js:explode &quot;var Person = @safeDefclass(Person, name, shoeSize);&quot;)
&quot;var Person = function() {
    function Person(name, shoeSize) {
        this.name = name;
        this.shoeSize = shoeSize;
    }
    return function(name, shoeSize) {
        return new Person(name, shoeSize);
    };
}();&quot;
</code></pre>

<p>So composing macros (<code>@safeDefclass</code> expands into a call to <code>@iife</code>)
works.</p>

<h3>Defining <code>@whenLet</code></h3>

<p>The <code>@whenLet</code> invocation in the examples isn&apos;t very suitable for
defining <code>@whenLet</code>. We can do with a shorter body and more than one
variable in the &lsquo;let&rsquo; part. Let&apos;s use this invocation:</p>

<pre><code>@whenLet(t1, 1, t2, 2, t3, 3; f(t1, t2, t3););
</code></pre>

<p>This is an &lsquo;args and body&rsquo; macro (the <code>test1, 1, test2, 2, test3, 3</code>
is the &lsquo;args&rsquo; part, <code>f(t1, t2, t3);</code> is the body). They are separated
by a semicolon. Let&apos;s tell Cheat-JS about this macro:</p>

<pre><code>&gt; (cheat-js:register-args-and-body-macro &quot;@whenLet&quot;)
</code></pre>

<p>The AST of the invocation:</p>

<pre><code>&gt; (cheat-js:parse-js &quot;@whenLet(t1, 1, t2, 2, t3, 3; f(t1, t2, t3););&quot;)
(:TOPLEVEL
 ((:STAT
   (:MACRO-CALL (:NAME &quot;@whenLet&quot;)
    ((:ARGS (:NAME &quot;t1&quot;) (:NUM 1) (:NAME &quot;t2&quot;) (:NUM 2) (:NAME &quot;t3&quot;) (:NUM 3))
     (:BODY
      (:STAT (:CALL (:NAME &quot;f&quot;) ((:NAME &quot;t1&quot;) (:NAME &quot;t2&quot;) (:NAME &quot;t3&quot;))))))))))
</code></pre>

<p>The <code>:MACRO-CALL</code> node has subnodes for both <code>:ARGS</code> and <code>:BODY</code>, they
will be both passed to our expander function.</p>

<p>What about the expansion? As the
<a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Data-and-Control-Flow" ><code>when-let</code> documentation</a>
says, <code>@whenLet</code> should run the statements in its body if all the
bound variables are true. And it would be nice to have a new scope for
our variables, so this is a suitable expansion:</p>

<pre><code>(function(t1, t2, t3) {
    if (t1 &amp;&amp; t2 &amp;&amp; t3) {
        f(t1, t2, t3);
    }
})(1, 2, 3);
</code></pre>

<p>The AST of the expansion:</p>

<pre><code>&gt;(cheat-js:parse-js &quot;(function(t1, t2, t3) {
                         if (t1 &amp;&amp; t2 &amp;&amp; t3) {
                             f(t1, t2, t3);
                         }
                     })(1, 2, 3);&quot;)
(:TOPLEVEL
 ((:STAT
   (:CALL
    (:FUNCTION NIL (&quot;t1&quot; &quot;t2&quot; &quot;t3&quot;)
     ((:IF (:BINARY :&amp;&amp; (:BINARY :&amp;&amp; (:NAME &quot;t1&quot;) (:NAME &quot;t2&quot;)) (:NAME &quot;t3&quot;))
       (:BLOCK
        ((:STAT (:CALL (:NAME &quot;f&quot;) ((:NAME &quot;t1&quot;) (:NAME &quot;t2&quot;) (:NAME &quot;t3&quot;))))))
       NIL)))
    ((:NUM 1) (:NUM 2) (:NUM 3))))))
</code></pre>

<p>So we need to transform the <code>:MACRO-CALL</code> node of the invocation into
the topmost <code>:CALL</code> node of the expansion:</p>

<pre><code>(defun when-let-expander (args body)
  (let* ((grouped-args (group args 2))
         (arg-vars (mapcar #'first grouped-args))
         (arg-values (mapcar #'second grouped-args))
         (arg-var-names (mapcar #'second arg-vars)))
    `(:CALL
      (:FUNCTION NIL ,arg-var-names
                 ((:IF ,(make-binary-and-ast arg-vars)
                       (:BLOCK
                        ,body)
                       NIL)))
      ,arg-values)))
</code></pre>

<p>Notice that <code>when-let-expander</code> has two arguments, <code>args</code> and <code>body</code>,
which contain the contents of the <code>:ARGS</code> and <code>:BODY</code> nodes of the
<code>:MACRO-CALL</code> tree. This function uses two helper functions shown
below:</p>

<pre><code>(defun group (list n)
  (if (&lt; (length list) n)
      (if list
          (list list))
      (cons (subseq list 0 n)
            (group (subseq list n) n))))

(defun make-binary-and-ast (operands)
  (cond ((= 1 (length operands))
         (first operands))
        ((= 2 (length operands))
         (list* :binary :&amp;&amp; operands))
        ((&gt; (length operands) 2)
         (let ((first-two (subseq operands 0 2))
               (rest (subseq operands 2)))
           (make-binary-and-ast (cons (make-binary-and-ast first-two)
                                      rest))))
        (t (error &quot;Incorrect number of operands for @whenLet.&quot;))))
</code></pre>

<p>We need <code>group</code> to help with destructuring the variables and values,
and <code>make-binary-and-ast</code> to build valid AST trees for &lsquo;and&rsquo;-ing more
than two operands.</p>

<p>Let&apos;s test our function:</p>

<pre><code>&gt; (let ((args '((:NAME &quot;t1&quot;) (:NUM 1)
                (:NAME &quot;t2&quot;) (:NUM 2)
                (:NAME &quot;t3&quot;) (:NUM 3)))
        (body '((:STAT
                 (:CALL (:NAME &quot;f&quot;)
                        ((:NAME &quot;t1&quot;) (:NAME &quot;t2&quot;) (:NAME &quot;t3&quot;)))))))
    (when-let-expander args body))
(:CALL
 (:FUNCTION NIL (&quot;t1&quot; &quot;t2&quot; &quot;t3&quot;)
  ((:IF (:BINARY :&amp;&amp; (:BINARY :&amp;&amp; (:NAME &quot;t1&quot;) (:NAME &quot;t2&quot;)) (:NAME &quot;t3&quot;))
    (:BLOCK
     ((:STAT (:CALL (:NAME &quot;f&quot;) ((:NAME &quot;t1&quot;) (:NAME &quot;t2&quot;) (:NAME &quot;t3&quot;))))))
    NIL)))
 ((:NUM 1) (:NUM 2) (:NUM 3)))
</code></pre>

<p>The result of the function is identical to our desired expansion, so
we can install our expander and test our new macro:</p>

<pre><code>&gt; (cheat-js:register-macro-expander &quot;@whenLet&quot; #'when-let-expander)
&gt; (cheat-js:explode &quot;@whenLet(t1, 1, t2, 2, t3, 3; f(t1, t2, t3););&quot;)
&quot;(function(t1, t2, t3) {
    if (t1 &amp;&amp; t2 &amp;&amp; t3) {
        f(t1, t2, t3);
    }
})(1, 2, 3);&quot;
</code></pre>

<p>Exercises: </p>

<ol>
<li>Can you define <code>@let</code> by simplifyind <code>@whenLet</code> a little?</li>
<li>Can you define <code>@iife</code> so <code>@iife(console.log(1);)</code> expands into
 <code>@let(;console.log(1);)</code>? Why is the first semicolon (just after the
 opening paren) necessary in the last <code>@let</code> invocation?</li>
</ol>

<h3>Defining <code>@awhen</code></h3>

<p>&hellip; should be very easy. <code>awhen</code>, defined in <em>On Lisp</em>, page 190, is
just <code>when-let</code> with one anaphoric variable, <code>it</code>. So the invocation:</p>

<pre><code>@awhen(expr;f(it);)
</code></pre>

<p>should expand into:</p>

<pre><code>@whenLet(it, expr;f(it);)
</code></pre>

<p>Let&apos;s declare <code>@awhen</code> to be an &lsquo;args and body&rsquo; macro:</p>

<pre><code>&gt; (cheat-js:register-args-and-body-macro &quot;@awhen&quot;)
</code></pre>

<p>If you have restarted your REPL after reading the last section, please
make sure to redefine <code>@whenLet</code> in your new REPL.</p>

<p>The AST of the invocation:</p>

<pre><code>&gt; (cheat-js:parse-js &quot;@awhen(expr;f(it);)&quot;)
(:TOPLEVEL
 ((:STAT
   (:MACRO-CALL (:NAME &quot;@awhen&quot;)
    ((:ARGS (:NAME &quot;expr&quot;))
     (:BODY (:STAT (:CALL (:NAME &quot;f&quot;) ((:NAME &quot;it&quot;))))))))))
</code></pre>

<p>The AST of the expansion:</p>

<pre><code>&gt; (cheat-js:parse-js &quot;@whenLet(it, expr;f(it);)&quot;)
(:TOPLEVEL
 ((:STAT
   (:MACRO-CALL (:NAME &quot;@whenLet&quot;)
    ((:ARGS (:NAME &quot;it&quot;) (:NAME &quot;expr&quot;))
     (:BODY (:STAT (:CALL (:NAME &quot;f&quot;) ((:NAME &quot;it&quot;))))))))))         
</code></pre>

<p>The expander:</p>

<pre><code>(defun awhen-expander (args body)
  `(:MACRO-CALL (:NAME &quot;@whenLet&quot;)
                ((:ARGS (:NAME &quot;it&quot;) ,(first args))
                 (:BODY ,@body))))
</code></pre>

<p>Let&apos;s install the expander and test <code>@awhen</code>:</p>

<pre><code>&gt; (cheat-js:register-macro-expander &quot;@awhen&quot; #'awhen-expander)
&gt; (cheat-js:explode &quot;@awhen(expr;f(expr););&quot;)
&quot;(function(it) {
    if (it) {
        f(expr);
    }
})(expr);&quot;
</code></pre>

<p>It works!</p>

<h3>More macros</h3>

<p>See the
<a href="https://github.com/mbrezu/Cheat-JS/blob/master/REFERENCE.md" >reference</a>
for macros already packaged with Cheat-JS.</p>

<h3>Conclusion</h3>

<p>To define a Cheat-JS macro, you need to know the three things required
for any macro: the invocation, the expansion, the transformation. </p>

<p>You also need to call one of the <code>cheat-js:register-*-macro</code> functions
to declare the type of your macro and
<code>cheat-js:register-macro-expander</code> to install the expander
function. It&apos;s best to call <code>cheat-js:clear-macros</code> before your macro
definitions to start clean.</p>

<p>Use <code>cheat-js:explode</code> to macroexpand JavaScript code after you
defined the macros.</p>

<h2>Troubleshooting</h2>

<p>Right now Cheat-JS doesn&apos;t give very nice error messages when parsing
a macro invocation fails; I&apos;ll try to improve error handling there.</p>

<p>If things break, right now the best course is to isolate the problem
(it&apos;s a problem in the expander? is the expected AST for the expansion
incorrect? etc.). The examples above should provide some information
about how Cheat-JS works. Reading <code>cheat-js.lisp</code> (rather small right
now, less than a hundred lines) and the <code>tests.lisp</code> files may provide
more clues about what Cheat-JS expects from a macro definition.</p>

<h2>Closing thoughts</h2>

<p>Still reading? Wow!</p>

<p>One thing is obvious: Cheat-JS makes it possible to write macro-like
transformations on JavaScript code, but it&apos;s not nearly as easy as
writing Common Lisp macros. Maybe this isn&apos;t a bad thing - we should
be writing macros only when there&apos;s no other way to avoid code
duplication.</p>

<p>There are plenty of quirks. There&apos;s only so many transformations you
can do (function calls are not as frequent in JavaScript as they are
in Common Lisp, and macro invocations are &lsquo;hooked&rsquo; to function
calls). Maybe <code>parse-js</code> could be tweaked harder to make it possible
to insert macros at other points. For now, the transformations
possible with &lsquo;function call&rsquo; macros are enough for me.</p>

<p>You need to be able to &lsquo;pattern match&rsquo; ASTs and figure out how to
transform macro invocations ASTs into macro expansions ASTs. This is a
basic macro writing skill, but with an indirection (in Common Lisp the
source code is the AST, not so with JavaScript).</p>

<p>You also need to know Common Lisp. In theory, a Cheat-JS based
preprocessor could be distributed and used by people who are only
&lsquo;consuming&rsquo; macros produced by someone else (a &lsquo;macro
producer&rsquo;). Hmmm, people will certainly be amused if a &lsquo;macro
producer&rsquo; starts distributing a 40MB executable (this is about the
minimum size for SBCL standalone executables) that explodes constructs
in the source code into larger code :-)</p>

<p>With a JavaScript parser written in JavaScript it would be possible to
do what Cheat-JS does without Common Lisp (though without backquotes
the generation of macro expansions is probably a pain, and the AST
would have to be uniform - nested arrays, no classes, maybe? - to make
it easier to &lsquo;pattern match&rsquo; and analyze).</p>

<p>Right now, the audience of Cheat-JS is probably the audience of
ParenScript (mostly because you need to be a lisper to fully use
Cheat-JS). I (Miron Brezuleanu) wrote a few thousands of lines of
ParenScript code and found that there is some &lsquo;impedance mismatch&rsquo;
between ParenScript and JavaScript (especially around the &apos;.&apos; operator
in JavaScript and modules in JavaScript). This was most likely my
fault: instead of writing Lisp to be compiled to JavaScript, I was
trying to write JavaScript with s-expressions. I found it harder to
write code in ParenScript than in JavaScript, and the presence of
macros didn&apos;t compensate for this extra effort. I tried to find a way
to have macros while writing something closer to JavaScript. Cheat-JS
is what I came up with.</p>

<p>Thanks for taking the time to read about Cheat-JS; I hope you&apos;ll find
it useful (or at least amusing - or both)!</p>

<p>Please use the Github
<a href="https://github.com/mbrezu/cheat-js/issues" >issues page</a> to report any
bugs or to post feature requests.</p>
