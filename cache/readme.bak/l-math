<h1>L-MATH</h1>

<p>L-MATH is a library for performing simple linear algebra. Vector and
matrix classes are available, as are simple linear interpolation
functions, spline-based interpolations (Catmull-Rom and B-Spline
methods), and various operations related to creating rotation matrices.</p>

<p>L-MATH also contains various spline implementations, including those
implemented using matrices:</p>

<ul>
<li>Hermite curves</li>
<li>Cubic Beziér curves</li>
<li>Uniform, non-rational B-Splines</li>
<li>Catmull-Rom splines</li>
</ul>

<p>There are also general splines that are calculated using recurrence
formulae (which is generally a more stable approach than using
matrices), such as:</p>

<ul>
<li>General Beziér curves of arbitrary degree</li>
<li>Non-Rational B-Splines, including uniform and non-uniform
  parametrisations.</li>
</ul>

<p>In addition, L-MATH contains various functions for creating random
data, including:</p>

<ul>
<li>uniformly distributed random numbers and vectors</li>
<li>normal distribution of random numbers and vectors</li>
<li>Perlin noise.</li>
</ul>

<h2>Vector</h2>

<p>Vectors can be constructed using the VECTOR and TO-VECTOR
functions. VECTOR accepts a list of elements, like so:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:vector 1 2 3</span>)</span> =&gt; #&lt;L-MATH:VECTOR 1.000 2.000 3.000 &gt;</span></code></pre>

<p>The VECTOR&apos;s dimension is defined by the number of elements in the
VECTOR function&apos;s lambda list.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:dimension <span class="paren2">(<span class="code">lm:vector 1 2 3 4</span>)</span></span>)</span> =&gt; 4</span></code></pre>

<p>TO-VECTOR is intended to transform other types into the VECTOR
type. At the moment it supports transforming lists and, trivially,
other vector objects:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:to-vector <span class="paren2">(<span class="code">list 1 2 3</span>)</span></span>)</span> =&gt; #&lt;L-MATH:VECTOR 1.000 2.000 3.000 &gt;</span></code></pre>

<p>Importantly, TO-VECTOR allows the vector&apos;s length to be modified:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:to-vector <span class="paren2">(<span class="code">list 1 2 3</span>)</span> <span class="keyword">:dimension</span> 2</span>)</span> =&gt; #&lt;L-MATH:VECTOR 1.000 2.000 &gt;
<span class="paren1">(<span class="code">lm:to-vector <span class="paren2">(<span class="code">lm:vector 1 2</span>)</span> <span class="keyword">:dimension</span> 3</span>)</span> =&gt; #&lt;L-MATH:VECTOR 1.000 2.000 0.000 &gt;</span></code></pre>

<p>Vectors can typically be represented as lists. For instance:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:dot-product <span class="paren2">(<span class="code">lm:vector 1 0 1</span>)</span> <span class="paren2">(<span class="code">list 0 1 0</span>)</span></span>)</span> =&gt; 0</span></code></pre>

<p>Various operations (listed below) are available for VECTOR
objects. Many of these functions will also accept lists as VECTOR
representations.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:dimension VECTOR</span>)</span></span></code></pre>

<p>Returns the VECTOR&apos;s dimension.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:length VECTOR</span>)</span></span></code></pre>

<p>Synonym for DIMENSION.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:norm VECTOR</span>)</span></span></code></pre>

<p>Returns the VECTOR&apos;s length.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:vector= LHS RHS</span>)</span></span></code></pre>

<p>Returns T iff the two vectors are equal. Internally, the VECTOR class
stores the data as an array of double-floats. Because of rounding
errors it is not advisable to compare floating point values
exactly. VECTOR= uses the special variable <em>equivalence-tolerance</em> to
define the tolerance within which two vectors are considered
equal. <em>equivalence-tolerance</em> defaults to 0.0001, which should be
reasonable for most applications. For example:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:vector= <span class="paren2">(<span class="code">lm:vector 1 2 3</span>)</span> <span class="paren2">(<span class="code">lm:vector 1 2 3.1</span>)</span></span>)</span> =&gt; NIL
<span class="paren1">(<span class="code">lm:vector= <span class="paren2">(<span class="code">lm:vector 1 2 3</span>)</span> <span class="paren2">(<span class="code">lm:vector 1 2 3.00001</span>)</span></span>)</span> =&gt; T</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:elt VECTOR index</span>)</span></span></code></pre>

<p>Returns the element at the given index. This is also a SETFable
place. VECTORs are zero based.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:x VECTOR</span>)</span> <span class="paren1">(<span class="code">lm:y VECTOR</span>)</span> <span class="paren1">(<span class="code">lm:z VECTOR</span>)</span> <span class="paren1">(<span class="code">lm:w VECTOR</span>)</span></span></code></pre>

<p>Returns the elements at indices 0, 1, 2 and 3 respectively. These are
all SETFable places.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:dot-product VECTOR</span>)</span></span></code></pre>

<p>Returns the VECTOR&apos;s dot product.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:cross-product LHS RHS</span>)</span></span></code></pre>

<p>Calculates the cross product between two 3-vectors.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:angle-between FROM-VECTOR TO-VECTOR</span>)</span></span></code></pre>

<p>Returns the angle, in radians, needed to align the FROM-VECTOR with
the TO-VECTOR. The angle is signed, and is a left-handed
rotation. Example:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:to-degrees <span class="paren2">(<span class="code">lm:angle-between <span class="paren3">(<span class="code">lm:vector 1 0</span>)</span> <span class="paren3">(<span class="code">lm:vector 0 1</span>)</span></span>)</span></span>)</span> =&gt; 90.0d0
<span class="paren1">(<span class="code">lm:to-degrees <span class="paren2">(<span class="code">lm:angle-between <span class="paren3">(<span class="code">lm:vector 1 0</span>)</span> <span class="paren3">(<span class="code">lm:vector 0 -1</span>)</span></span>)</span></span>)</span> =&gt; -90.0d0</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:euclidean-distance LHS RHS</span>)</span></span></code></pre>

<p>Calculates the Euclidean distance between two vectors or two numbers.</p>

<h2>Matrix</h2>

<p>Matrices can be constructed using (lm:MAKE-MATRIX row col &amp;key initial-elements)</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:make-matrix 2 3 <span class="keyword">:initial-elements</span> '<span class="paren2">(<span class="code">1 0 0
                            0 1 0</span>)</span></span>)</span>
=&gt;                  
#&lt;L-MATH:MATRIX 2 x 3
1.000 0.000 0.000 
0.000 1.000 0.000 &gt;</span></code></pre>

<p>If :initial-elements isn&apos;t specified, the matrix elements are
initialised to zero.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:matrix= LHS RHS</span>)</span></span></code></pre>

<p>Ensures that two matrices are numerically equivalent. All the
real-valued components must be within <em>equivalence-tolerance</em> of each
other.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:matrix-rows MATRIX</span>)</span> <span class="paren1">(<span class="code">lm:matrix-cols MATRIX</span>)</span></span></code></pre>

<p>Returns the number of rows and columns in the matrix.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:matrix-elt MATRIX row col</span>)</span></span></code></pre>

<p>Returns the element at the given row and column. MATRIX objects are
zero based. This is a SETFable place.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:make-identity SIZE</span>)</span></span></code></pre>

<p>Returns a SIZE×SIZE identity matrix.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:roll-matrix SIZE ANGLE</span>)</span></span></code></pre>

<p>Returns SIZE×SIZE matrix which will rotate a post multiplied vector
around the z-axis. It is a left-handed rotation. The ANGLE is given in
radians. SIZE should be either 3 or 4.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:yaw-matrix SIZE ANGLE</span>)</span></span></code></pre>

<p>Returns SIZE×SIZE matrix which will rotate a post multiplied vector
around the y-axis. It is a left-handed rotation. The ANGLE is given in
radians. SIZE should be either 3 or 4.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:pitch-matrix SIZE ANGLE</span>)</span></span></code></pre>

<p>Returns SIZE×SIZE matrix which will rotate a post multiplied vector
around the x-axis. It is a left-handed rotation. The ANGLE is given in
radians. SIZE should be either 3 or 4.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:set-rotation-naming-convention CONVENTION</span>)</span></span></code></pre>

<p>Rebinds YAW-MATRIX, PITCH-MATRIX, and ROLL-MATRIX to rotate around
different axes. The available conventions are provided in
<em>lm:*rotation-naming-conventions</em>*</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:create-rotation-matrix VIEW RIGHT UP &amp;optional <span class="paren2">(<span class="code">SIZE 3</span>)</span></span>)</span></span></code></pre>

<p>Creates a rotation matrix from three vectors. VIEW is the direction
that the resulting vector should be pointing along, UP is the direction
upwards. RIGHT is the vector orthogonal to this. Will return a
left-handed rotation matrix. SIZE is the size of the matrix, and
should be either 3 or 4.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:create-rotation-from-view VIEW WORLD-UP &amp;optional <span class="paren2">(<span class="code">SIZE <span class="paren3">(<span class="code">length SIZE</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>Given a direction to look in (VIEW), and the direction that is
&lsquo;upwards&rsquo; in a given coordinate system, this function creates a
rotation matrix to translate into that coordinate system. This
rotation is left-handed. SIZE should be either 3 or 4. </p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:create-rotation-from-view-to-view FROM-VIEW TO-VIEW WORLD-UP</span>)</span></span></code></pre>

<p>Creates a rotation matrix that will rotate the vector FROM-VIEW on to
the vector TO-VIEW, using WORLD-UP as the coordinate system&apos;s &lsquo;upward&rsquo;
direction. This is a left-handed rotation. Example:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">rotation <span class="paren4">(<span class="code">lm:create-rotation-from-view-to-view <span class="paren5">(<span class="code">lm:vector 1 0 0</span>)</span> 
                              <span class="paren5">(<span class="code">lm:vector 0 1 0</span>)</span> 
                              <span class="paren5">(<span class="code">lm:vector 0 0 1</span>)</span></span>)</span></span>)</span></span>)</span>
       <span class="paren2">(<span class="code">lm:* rotation <span class="paren3">(<span class="code">lm:vector 1 0 0</span>)</span></span>)</span></span>)</span>
=&gt; #&lt;L-MATH:VECTOR 0.000 1.000 0.000 &gt;</span></code></pre>

<h2>Interpolation</h2>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:linear-interpolation START END T-VAL</span>)</span></span></code></pre>

<p>Given two vectors (START and END), and a real valued parameter
(T-VAL), this returns a vector between START and END. When T-VAL is
zero, this returns START. When T-VAL is 1, this returns END. Values
between 0 and 1 return vectors between START and END; values below
zero return vectors &ldquo;before&rdquo; START; values above 1 return vectors
&ldquo;after&rdquo; END. The value 0.5 returns the vector exactly between START
and END. Example:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:linear-interpolation <span class="paren2">(<span class="code">lm:vector -1 0</span>)</span> <span class="paren2">(<span class="code">lm:vector 1 0</span>)</span> 0.5</span>)</span>
=&gt; #&lt;L-MATH:VECTOR 0.000 0.000 &gt;
<span class="paren1">(<span class="code">lm:linear-interpolation <span class="paren2">(<span class="code">lm:vector 0 0 0</span>)</span> <span class="paren2">(<span class="code">lm:vector 10 10 10</span>)</span> 2</span>)</span>
=&gt; #&lt;L-MATH:VECTOR 20.000 20.000 20.000 &gt;</span></code></pre>

<p>This method also accepts arbitrary numbers, and will interpolate
between them:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:linear-interpolation 0 100 0.5</span>)</span> =&gt; 50.0</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:between START END</span>)</span></span></code></pre>

<p>Returns the vector exactly between the VECTORs START and END.</p>

<h2>General Operations</h2>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:equivalent LHS RHS</span>)</span></span></code></pre>

<p>Returns t iff the two objects are numerically equivalent. Numbers are
tested using =. Real-valued objects (REAL types, VECTORs and MATRIXs)
are compared to each other using a tolerance
<em>equivalence-tolerance</em>. VECTORs and MATRIX objects are compared using
VECTOR= and MATRIX=.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:copy OBJECT</span>)</span></span></code></pre>

<p>Returns a copy of the given VECTOR, MATRIX or list.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:negate OBJECT</span>)</span> <span class="paren1">(<span class="code">lm:negate! OBJECT</span>)</span></span></code></pre>

<p>Returns the arithmetic inverse of the given object. NEGATE! does so
destructively. Example:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:negate <span class="paren2">(<span class="code">list 1 -2 3</span>)</span></span>)</span> =&gt; <span class="paren1">(<span class="code">-1 2 -3</span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:to-radians ANGLE</span>)</span> <span class="paren1">(<span class="code">lm:to-degrees ANGLE</span>)</span></span></code></pre>

<p>Converts from radians to degrees, and vice versa.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">lm:test-dimensions LHS RHS</span>)</span></span></code></pre>

<p>Ensures that the two items have the same dimensions. The items may be
lists, vectors or matrices in most sensible combinations. This
function is useful when implementing your own operations between
vectors and matrices to ensure that their dimensions agree. If they do
not, a DIMENSION-ERROR condition is signalled.</p>

<h2>Arithmetic operations</h2>

<p>All the general arithmetic operations are defined:</p>

<pre><code><span class="code">* <span class="paren1">(<span class="code">lm:+ LHS RHS</span>)</span>
* <span class="paren1">(<span class="code">lm:- LHS RHS</span>)</span>
* <span class="paren1">(<span class="code">lm:- OBJECT</span>)</span>
* <span class="paren1">(<span class="code">lm:* LHS RHS</span>)</span>
* <span class="paren1">(<span class="code">lm:/ LHS RHS</span>)</span></span></code></pre>

<h2>Conditions</h2>

<p>L-MATH-ERROR: A general condition from which all error conditions for
the package inherit.</p>

<p>DIMENSION-ERROR: This is signalled when an operation is requested on
objects whose dimensions are inappropriate.</p>

<p>ZERO-NORM-ERROR: This is signalled on operations which do not make
sense for vectors with zero norm.</p>

<p>OPERATION-NOT-SUPPORTED: This is signalled when an arithmetic
operation is requested on two objects for which the operation is not
supported. This should usually not occur, and probably should be
considered a bug if it does.</p>

<h2>General Comments</h2>

<p>Both VECTOR and MATRIX classes have load forms
(MAKE-LOAD-FORM). Internally, the data is stored as arrays of
DOUBLE-FLOAT values.</p>

<p>For those operations which deal with rotations, note that rotation
matrices should be post-multiplied by the vectors. The coordinate
system is left-handed, as are the rotations.</p>

<h2>Supported Compilers</h2>

<p>L-MATH is known to work on SBCL 1.0.29 and 1.0.55. While it should
work on other compilers, this so far has not been tested. Please feel
free to send in reports of which compilers you&apos;ve successfully run
this with, or to file bug reports where L-MATH is having problems.</p>

<h2>Getting and Installing</h2>

<p>L-MATH is available from its <a href="http://www.common-lisp.net/projects/l-math/" title="Common Lisp.net">home page</a> at Common Lisp.net, or
from its <a href="https://github.com/TheRiver/L-MATH" title="Github Repository">github repository</a>. L-MATH can be installed using
ASDF-INSTALL and QUICKLISP:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">require 'asdf-install</span>)</span>
<span class="paren1">(<span class="code">asdf-install:install 'l-math</span>)</span>

<span class="paren1">(<span class="code">quicklisp:quickload 'l-math</span>)</span></span></code></pre>

<h2>Reporting Bugs</h2>

<p>Bugs can be reported to https://github.com/TheRiver/L-MATH. </p>

<h2>License</h2>

<p>See the file LICENSE for the licensing details. In brief, L-MATH is
licensed under the GPL, with additional permissions giving link
exceptions (aka the Classpath exception). Importantly for a Common
Lisp library, this exception allows you to use this GPLed library in
your application regardless of the licenses of the compiler and the
other libraries you are using (as long, of course, as you satisfy
those licenses).</p>

<p>Note that this does not remove the obligation that the rest of the GPL
places on you, such as supplying the source code of this library.</p>
