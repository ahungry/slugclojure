<h1>check-it</h1>

<p><a href="https://travis-ci.org/DalekBaldwin/check-it" ><img src="https://travis-ci.org/DalekBaldwin/check-it.svg?branch=master" alt="Build Status" /></a></p>

<p>This is a randomized property-based testing library for Common Lisp. Rather than being a full-fledged general test framework in its own right, it&apos;s designed to embed randomized tests in whatever framework you like.</p>

<p>The basic idea behind QuickCheck-style tools is simple, but they become complicated as different features interact, so some behaviors and API details may not be stable. I recommend that you configure your projects&apos; test systems to optionally exclude check-it tests (e.g. by keeping them all in a separate package from your other tests) so that a breaking change won&apos;t impede your development workflow too much.</p>

<h2>Table of Contents</h2>

<ul>
<li><a href="#generating" >Generating</a>

<ul>
<li><a href="#number-generators" >Number Generators</a></li>
<li><a href="#character-generators" >Character Generators</a></li>
<li><a href="#list-and-tuple-generators" >List and Tuple Generators</a></li>
<li><a href="#string-generator" >String Generator</a></li>
<li><a href="#or-generator" >Or Generator</a></li>
<li><a href="#guard-generator" >Guard Generator</a></li>
<li><a href="#struct-generator" >Struct Generator</a></li>
<li><a href="#mapped-generators" >Mapped Generators</a></li>
<li><a href="#chained-generators" >Chained Generators</a></li>
<li><a href="#user-defined-generators" >User-Defined Generators</a></li>
<li><a href="#generator-macros" >Generator Macros</a></li>
</ul></li>
<li><a href="#checking" >Checking</a>

<ul>
<li><a href="#regression-cases" >Regression Cases</a></li>
<li><a href="#note-on-mapped-generators" >Note on Mapped Generators</a></li>
</ul></li>
<li><a href="#shrinking" >Shrinking</a>

<ul>
<li><a href="#note-on-destructive-operations" >Note on Destructive Operations</a></li>
</ul></li>
</ul>

<h2>Generating</h2>

<p>The heart of check-it is the generator DSL. Generator objects are constructed using the macro <code>generator</code>, which takes a single argument: a form denoting a type spec. Generator type specs are not exactly the same as Common Lisp type specs, but they&apos;re designed to look syntactically similar.</p>

<p>Values are generated by calling the function <code>generate</code> on generator objects. This function is normally called behind the scenes during a test run, but it can also be used Ã  la carte to generate interesting data for other purposes.</p>

<p>The different varieties of generators are:</p>

<h3>Number Generators</h3>

<p>The <code>integer</code> generator accepts the same syntax as the standard compound type specifier syntax for integers:</p>

<pre><code><span class="code"><span class="comment">;; generates any integer
</span><span class="paren1">(<span class="code">integer</span>)</span>

<span class="comment">;; also generates any integer
</span><span class="paren1">(<span class="code">integer * *</span>)</span>

<span class="comment">;; generates integers greater than or equal to 5
</span><span class="paren1">(<span class="code">integer 5</span>)</span>

<span class="comment">;; generates integers less than or equal to 10
</span><span class="paren1">(<span class="code">integer * 10</span>)</span>

<span class="comment">;; generates integers between -3 and 4
</span><span class="paren1">(<span class="code">integer -3 4</span>)</span></span></code></pre>

<p>The <code>real</code> generator works similarly.</p>

<p>A number generator&apos;s bounds can also be expressions: <code>(real 0 (* 2 pi))</code></p>

<p>You could even do things like this if you wanted:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">x <span class="paren4">(<span class="code">something</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">real 0 x</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>But you should probably define a custom generator type or use a combinator like <code>map</code> or <code>chain</code> instead.</p>

<p>In addition to the constraints you choose in the type specifier, the absolute values of generated numbers are also bounded by the parameter <code>*size*</code>.</p>

<h3>Character Generators</h3>

<p>The <code>character</code> generator accepts a syntax much like the number generators. It accepts either characters or character codes as bounding values:</p>

<pre><code><span class="code"><span class="comment">;; any character
</span><span class="paren1">(<span class="code">character</span>)</span>

<span class="comment">;; any character, again
</span><span class="paren1">(<span class="code">character * *</span>)</span>

<span class="paren1">(<span class="code">character <span class="character">#\a</span> <span class="character">#\f</span></span>)</span>

<span class="comment">;; same as previous
</span><span class="paren1">(<span class="code">character 97 102</span>)</span></span></code></pre>

<p>Two additional character generators are predefined for common cases: <code>alpha</code> for <code>#\a</code>-<code>#\z</code> and <code>#\A</code>-<code>#\Z</code>, and <code>alphanumeric</code> for <code>#\a</code>-<code>#\z</code>, <code>#\A</code>-<code>#\Z</code>, and <code>#\0</code>-<code>#\9</code>.</p>

<h3>List and Tuple Generators</h3>

<p>The <code>list</code> generator generates a list of values each generated by its subgenerator. The generated list has a random length bounded by the parameter <code>*list-size*</code>.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a-generator
       <span class="paren4">(<span class="code">generator <span class="paren5">(<span class="code">list <span class="paren6">(<span class="code">integer</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">generate a-generator</span>)</span></span>)</span>
<span class="comment">;; sample result: (9 -3 3 -2 3 10 6 -8 9 10)</span></span></code></pre>

<p>You can also specify length bounds with <code>:min-length</code> and <code>:max-length</code>:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">generator <span class="paren2">(<span class="code">list <span class="paren3">(<span class="code">integer</span>)</span> <span class="keyword">:min-length</span> 5 <span class="keyword">:max-length</span> 10</span>)</span></span>)</span></span></code></pre>

<p><code>:max-length</code> provides a permanent bound, but <code>*list-size*</code> can change in certain situations described further down in this document. For convenience, you can specify lists of fixed length with a single keyword argument:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">generator <span class="paren2">(<span class="code">list <span class="paren3">(<span class="code">integer</span>)</span> <span class="keyword">:length</span> 5</span>)</span></span>)</span></span></code></pre>

<p>The <code>tuple</code> generator generates a list containing one result from each of its subgenerators in order, so unlike the <code>list</code> generator, its length is fixed:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">another-generator
       <span class="paren4">(<span class="code">generator <span class="paren5">(<span class="code">tuple <span class="paren6">(<span class="code">integer</span>)</span> <span class="paren6">(<span class="code">real</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">generate another-generator</span>)</span></span>)</span>
<span class="comment">;; sample result: (-6 -4.168296)</span></span></code></pre>

<h3>String Generator</h3>

<p>A special form of the <code>list</code> generator (equally length bounded by <code>*list-size*</code>) is the <code>string</code> generator to generate strings consisting of randomly chosen alphanumeric characters.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">generate <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">string <span class="keyword">:min-length</span> 10 <span class="keyword">:max-length</span> 20</span>)</span></span>)</span></span>)</span>
<span class="comment">;; sample output: "2k464h72CZ4TE1KQ"</span></span></code></pre>

<h3>Or Generator</h3>

<p>The <code>or</code> generator randomly chooses one of its subgenerators and returns its result. It biases its choice in certain situations, to be described later.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">generate <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">or <span class="paren4">(<span class="code">integer</span>)</span> <span class="paren4">(<span class="code">real</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;; sample result: -1.0087109</span></span></code></pre>

<h3>Guard Generator</h3>

<p>The <code>guard</code> generator generates a result from its subgenerator and checks whether the result passes the guard predicate. If not, it keeps generating new results until it finds a value that does.</p>

<pre><code><span class="code"><span class="comment">;; same range of values as (integer 5)
</span><span class="paren1">(<span class="code">guard <span class="paren2">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="code">x</span>)</span> <span class="paren3">(<span class="code">&gt;= x 5</span>)</span></span>)</span> <span class="paren2">(<span class="code">integer</span>)</span></span>)</span></span></code></pre>

<h3>Struct Generator</h3>

<p>The <code>struct</code> generator generates a struct of a given struct type with slots generated by the corresponding slot generators. So if you have a struct definition that looks like:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defstruct</span></i> a-struct
  a-slot
  another-slot</span>)</span></span></code></pre>

<p>You can create a generator type spec that looks like:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">struct a-struct <span class="keyword">:a-slot</span> <span class="paren2">(<span class="code">integer</span>)</span> <span class="keyword">:another-slot</span> <span class="paren2">(<span class="code">real</span>)</span></span>)</span></span></code></pre>

<p>In order to use this kind of generator, the struct type must have a default constructor function. Of course, you can always use simple generators to specify all the atomic data elements you need and manually assemble them into more complex data structures at the start of your test body. However, for complex, nested generator forms, it may be difficult or impossible to unambiguously specify where to find the output of some deep sub-sub-generator that you wish to transform. For those situations, you need&hellip;</p>

<h3>Mapped Generators</h3>

<p>A mapped generator applies a transformation function to the outputs of its subgenerators. This is a mapping in the mathematical sense, not the Lispy one; it does not map the function repeatedly to each element of a list. The transformation function should not mutate its arguments.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="special">*size*</span> 100</span>)</span>
      <span class="paren3">(<span class="code">g <span class="paren4">(<span class="code">generator <span class="paren5">(<span class="code">tuple <span class="paren6">(<span class="code">map <span class="paren1">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren2">(<span class="code">x y</span>)</span> <span class="paren2">(<span class="code">list x y</span>)</span></span>)</span>
                                <span class="paren1">(<span class="code">integer 1 10</span>)</span>
                                <span class="paren1">(<span class="code">integer 20 30</span>)</span></span>)</span>
                           <span class="paren6">(<span class="code">map <span class="paren1">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren2">(<span class="code">x y</span>)</span> <span class="paren2">(<span class="code">list x <span class="paren3">(<span class="code">+ x y</span>)</span></span>)</span></span>)</span>
                                <span class="paren1">(<span class="code">integer 1 9</span>)</span>
                                10</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">generate g</span>)</span></span>)</span>
<span class="comment">;;; sample result: ((10 28) (7 17))</span></span></code></pre>

<h3>Chained Generators</h3>

<p>You can create generators whose behavior is parameterized by other generators with <code>chain</code>. Every time a value is created from a chained generator,</p>

<ol>
<li>Each parameterizing generator generates a new value,</li>
<li>Those values are bound to the associated variable names in the body of the <code>chain</code> form,</li>
<li>The body is evaluated to construct a new parameterized generator, and</li>
<li>The parameterized generator generates the end value.</li>
</ol>

<p>For example, you can generate random NxN matrices like this:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">g <span class="paren4">(<span class="code">generator
          <span class="paren5">(<span class="code">chain <span class="paren6">(<span class="code"><span class="paren1">(<span class="code">n <span class="paren2">(<span class="code">integer 1 5</span>)</span></span>)</span></span>)</span>
            <span class="paren6">(<span class="code">generator <span class="paren1">(<span class="code">list
                        <span class="paren2">(<span class="code">list <span class="paren3">(<span class="code">integer</span>)</span> <span class="keyword">:length</span> n</span>)</span>
                        <span class="keyword">:length</span> n</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">generate g</span>)</span></span>)</span>
<span class="comment">;; sample result: ((-2 0 -9 -6) (6 7 -3 -7) (9 -10 10 6) (-6 -10 -10 8))</span></span></code></pre>

<p>The <code>generator</code> macro is implicitly wrapped around each parameterizer form for brevity. However, the body is regular Lisp code, so you must use <code>generator</code> to define your parameterized generator there.</p>

<p>If you provide only a name for a parameterizer instead of a list containing a name and a generator form, the name is assumed to be a variable already bound to a generator in the surrounding Lisp code:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">x <span class="paren4">(<span class="code">generator <span class="paren5">(<span class="code">integer 1 3</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="code">y <span class="paren4">(<span class="code">generator <span class="paren5">(<span class="code">integer 8 10</span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">chain <span class="paren4">(<span class="code">x y</span>)</span>
               <span class="paren4">(<span class="code">list <span class="paren5">(<span class="code">integer</span>)</span> <span class="keyword">:min-length</span> x <span class="keyword">:max-length</span> y</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>User-Defined Generators</h3>

<p>You can define your own generator types with <code>def-generator</code>.</p>

<p>User-defined generators can take a set of arguments specified by an ordinary lambda list, evaluated at the time of a generator object&apos;s construction. They can also be recursive (in which case recursive definition is evaluated anew to construct a generator, allowing child recursions be parameterized by parent recursions). Here&apos;s a useless example:</p>

<pre><code><span class="code"><span class="comment">;; same range of values as (integer x)
</span><span class="paren1">(<span class="code"><i><span class="symbol">def-generator</span></i> recursive <span class="paren2">(<span class="code">x</span>)</span> <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">or <span class="paren4">(<span class="code">integer x</span>)</span> <span class="paren4">(<span class="code">recursive x</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>You can also create higher-order recursive generators. However, each subgenerator needs to be a unique object for check-it to work correctly, so you need to explicitly create them like this:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">def-generator</span></i> higher-order <span class="paren2">(<span class="code">generator-maker</span>)</span>
  <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">or <span class="paren4">(<span class="code">funcall generator-maker</span>)</span>
                 <span class="paren4">(<span class="code">higher-order generator-maker</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code">generate <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">higher-order <span class="paren4">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="code"></span>)</span> <span class="paren5">(<span class="code">generator <span class="paren6">(<span class="code">integer</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>With naive generation strategies, recursive generators can easily generate values of unbounded size. There are currently two ways to dampen the feedback explosion of recursively-generated data structures.</p>

<p>When a user-defined generator appears as an alternative in an <code>or</code> generator, its relative probability of being chosen decreases with each recursive descent.</p>

<pre><code><span class="code"><span class="comment">;; normally there would be an 87.5% chance of recursing on each generation
</span><span class="comment">;; essentially guaranteeing unbounded growth
</span><span class="paren1">(<span class="code"><i><span class="symbol">def-generator</span></i> tuple-explode <span class="paren2">(<span class="code">x</span>)</span>
  <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">tuple <span class="paren4">(<span class="code">or x <span class="paren5">(<span class="code">tuple-explode <span class="paren6">(<span class="code">+ 1 x</span>)</span></span>)</span></span>)</span>
                    <span class="paren4">(<span class="code">or x <span class="paren5">(<span class="code">tuple-explode <span class="paren6">(<span class="code">+ 1 x</span>)</span></span>)</span></span>)</span>
                    <span class="paren4">(<span class="code">or x <span class="paren5">(<span class="code">tuple-explode <span class="paren6">(<span class="code">+ 1 x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="special">*recursive-bias-decay*</span> 1.2</span>)</span>
      <span class="paren3">(<span class="code"><span class="special">*bias-sensitivity*</span> 1.5</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">generate <span class="paren3">(<span class="code">generator <span class="paren4">(<span class="code">tuple-explode 0</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;; sample result: (0 0 (1 1 ((3 (4 4 (5 5 5)) (4 4 (5 5 5))) (3 3 3) 2)))</span></span></code></pre>

<p>The change in bias at each recursive step is controlled by the parameter <code>*recursive-bias-decay*</code>, and the way biases of different alternatives interact to produce the actual relative probabilities is controlled by <code>*bias-sensitivity*</code>. The whole apparatus is set up in such a way that these parameters can be tuned without causing one alternative&apos;s probability to sharply shoot off toward zero or one, so you can play around with them and discover values that produce a reasonable distribution for your needs.</p>

<p>Additionally, the maximum possible list length is reduced with every <code>list</code> generation that occurs within the dynamic scope of another <code>list</code> generation.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">def-generator</span></i> list-explode <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">or <span class="paren4">(<span class="code">integer</span>)</span> <span class="paren4">(<span class="code">list <span class="paren5">(<span class="code">list-explode</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="special">*list-size*</span> 10</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">generate <span class="paren3">(<span class="code">generator <span class="paren4">(<span class="code">list-explode</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;; sample result:
</span><span class="comment">;; ((((-5 -9 (-7 -4)) NIL NIL (6) NIL) (-7 (3 (-4 (NIL)))) (5 -3) 3
</span><span class="comment">;;   ((1 (4) 5) NIL ((NIL) -10)) -5 9)
</span><span class="comment">;;  ((((-3) -6) NIL -4 (-5) -4)) ((-9) 0 1 0 3) -3 NIL)</span></span></code></pre>

<p>But it&apos;s your responsibility not to write type specs that can&apos;t possibly generate anything other than unbounded values.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">def-generator</span></i> inherently-unbounded <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">tuple <span class="paren4">(<span class="code">integer</span>)</span> <span class="paren4">(<span class="code">inherently-unbounded</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>Generator Macros</h3>

<p>You can define transformations using destructuring lambda lists that work just like macros within the generator DSL. These will be expanded in any place where a generator expression would be expected.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">def-genex-macro</span></i> maybe <span class="paren2">(<span class="code">form</span>)</span>
  `<span class="paren2">(<span class="code">or nil ,form</span>)</span></span>)</span>

<span class="paren1">(<span class="code">generate <span class="paren2">(<span class="code">generator <span class="paren3">(<span class="code">list <span class="paren4">(<span class="code">maybe <span class="paren5">(<span class="code">integer</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;; sample result: (NIL NIL NIL NIL 7 -4 2 NIL NIL 3 7 -8 NIL 7)</span></span></code></pre>

<h2>Checking</h2>

<p>Use the <code>check-it</code> macro to perform a test run. Here&apos;s another useless example:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="special">*num-trials*</span> 100</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">check-it <span class="paren3">(<span class="code">generator <span class="paren4">(<span class="code">integer</span>)</span></span>)</span>
            <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren4">(<span class="code">x</span>)</span> <span class="paren4">(<span class="code">integerp x</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>This will generate <code>*num-trials*</code> random values and test them against the test predicate. If a random value fails, check-it will search for values of smaller complexity until it finds the least complex value it can that fails the test while respecting the generator&apos;s composite type spec, and print a failure description to <code>*check-it-output*</code>.</p>

<p>If the test predicate signals an uncaught error, <code>check-it</code> will catch it and treat it as a test failure, both for the initial test and the search for smaller failing values. If you want to test for an expected error, you should explicitly handle it within the test predicate and return a non-<code>nil</code> value.</p>

<p><code>check-it</code> itself returns <code>t</code> if every trial passed and <code>nil</code> if one failed, so you can embed <code>check-it</code> forms within whatever test framework you&apos;re already using. Here&apos;s what a check-it test might look like using Stefil:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">deftest</span></i> useless-test <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><span class="special">*num-trials*</span> 100</span>)</span></span>)</span>
    <span class="paren3">(<span class="code">is <span class="paren4">(<span class="code">check-it <span class="paren5">(<span class="code">generator <span class="paren6">(<span class="code">integer</span>)</span></span>)</span>
                  <span class="paren5">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren6">(<span class="code">x</span>)</span> <span class="paren6">(<span class="code">integerp x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>Regression Cases</h3>

<p>You can configure the <code>check-it</code> macro to automatically add new deterministic regression tests to your project when a randomized test fails. Here&apos;s the worst example yet:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">deftest</span></i> some-test-with-regression-cases <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">is
   <span class="paren3">(<span class="code">check-it <span class="paren4">(<span class="code">generator <span class="paren5">(<span class="code">struct a-struct
                                <span class="keyword">:a-slot</span> <span class="paren6">(<span class="code">integer</span>)</span>
                                <span class="keyword">:another-slot</span> <span class="paren6">(<span class="code">integer</span>)</span></span>)</span></span>)</span>
             <span class="paren4">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="code">x</span>)</span> <span class="paren5">(<span class="code">= <span class="paren6">(<span class="code">slot-value x 'a-slot</span>)</span> 0</span>)</span></span>)</span>
             <span class="keyword">:regression-id</span> some-test-with-regression-cases
             <span class="keyword">:regression-file</span> my-regression-test-file</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>This will (most likely) discover a failing case, shrink it, and append the following code to <code>my-regression-test-file</code>:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">REGRESSION-CASE SOME-TEST-WITH-REGRESSION-CASES <span class="string">"#S(A-STRUCT :A-SLOT 1 :ANOTHER-SLOT 0)"</span></span>)</span></span></code></pre>

<p>Regression cases must be given a <code>regression-id</code> to know which <code>check-it</code> form they apply to. It&apos;s probably simplest just to tag them with the same symbol you used to name the test. (This makes your test code a little more redundant, but it keeps check-it simple and framework-agnostic.) Although generators are meant to generate data with readable print representations, some objects (like structs) cannot be dumped into FASL files, so regression cases are encoded as strings which are read after the file is loaded in order to delay their construction.</p>

<p>It is recommended that you output your regression cases to a special file that initially contains only the line <code>(in-package :same-package-as-test-package)</code> and is loaded as part of the same system as your tests. Then the next time you run a check-it test, all the regression cases will be checked before any random cases are generated, which should hopefully light a fire under your ass to fix bugs you&apos;ve already discovered before you hunt for new ones.</p>

<p>You can also provide a list of explicit inline examples that will also be checked before any random cases are generated using the <code>:examples</code> keyword argument to <code>check-it</code>.</p>

<p>Eventually, check-it will be integrated more elegantly with individual test frameworks by extending their APIs. For now, you can reduce code repetition by declaring a file to output regression cases for all <code>regression-id</code>s in a given package with <code>(register-package-regression-file :package file)</code>, so you don&apos;t have to mention the file in each test.</p>

<h4>Note on Mapped Generators</h4>

<p>All data types constructed with check-it&apos;s essential generators can be successfully converted to readable print representations, but it&apos;s possible that something you create with a mapped generator will produce a data type that can&apos;t. If you want to enable regression cases for tests involving unexternalizable data types, try to find a way to construct those data types within the test body if possible. Eventually, check-it may use a more robust solution for externalization, but this simple method can get you surprisingly far.</p>

<h2>Shrinking</h2>

<p>When a generated value fails a test, check-it searches for a simpler value as follows:</p>

<p>An <code>integer</code> generator shrinks toward zero, or if zero is not included in its range, toward the bound in its type spec that has the smaller absolute value.</p>

<p>A <code>real</code> generator doesn&apos;t shrink, because the shrinkage procedure only really makes sense over discrete search spaces.</p>

<p>A <code>list</code> generator shrinks by repeatedly removing elements from the list and/or shrinking individual elements while respecting the type spec of the subgenerator.</p>

<p>An <code>or</code> generator shrinks by shrinking the one generator among its alternatives that was involved in generating the failed value. However, if this generator&apos;s value cannot be shrunk further, and other alternatives available to the <code>or</code> generator specify constant values, then one of those constant values may be substituted instead. So if the generator <code>(or (integer 5) :a-keyword)</code> failed after generating 5 from the <code>integer</code> subgenerator, check-it will attempt to use <code>:a-keyword</code>. This opens up more possible shrinkage paths in the overall space defined by the <code>or</code> generator&apos;s parent generators.</p>

<p>Other generators shrink by recursively shrinking their subgenerators while still respecting the overall type spec.</p>

<p>For mapped generators, the subgenerators shrink according to their own internal degrees of freedom, but the mapping is applied to the candidate replacement values from the subgenerators to determine whether resulting composite data structure still fails the test. There&apos;s a bit of a thorny issue here in that check-it doesn&apos;t know for sure whether a simpler value in a subgenerator will really correspond to a simpler value after the mapping is applied. For this reason, good mapping functions should typically specify one-to-one mappings that simply assemble new data structures, and more complicated logic should go in the test body.</p>

<p>For chained generators, the parameterizers are not involved in the shrinking process; the parameterized generator is shrunk according to the parameters it had when it failed the test.</p>

<h3>Note on Destructive Operations</h3>

<p>Currently, generators cache their generated values and often make use of them during the shrinking process. If you perform destructive operations on the input to a test function, shrinking may not work correctly. This will be fixed eventually. In the meantime, you can turn off shrinking by giving <code>check-it</code> the keyword argument <code>:shrink-failures nil</code>.</p>
