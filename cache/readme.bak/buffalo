<h1>buffalo</h1>

<p>An LALR(1) and canonical LR(1) parser generator, written in pure
Common Lisp.</p>

<p>Buffalo is a parser generator: it computes parsing tables and
associated semantic actions out of a BNF grammar specification that is
then used by a pushdown automaton (also part of the package) to parse
input in the language specified by the grammar.</p>

<p>Buffalo&apos;s LALR(1) generator is a pure Common Lisp implementation of
the DeRemer/Pennello algorithm to compute lookahead sets, while
the LR(1) generator is based on Knuth&apos;s original canonical method.</p>

<p>Both generators use sparse sets, patricia tries, and other efficient
algorithms, to achieve very competitive compile times, in particular
noticeable for the LR(1) method and large grammars.</p>

<p>buffalo implements POSIX yacc-compatible conflict resolution mechanisms,
including per-production context-dependent precedence (%prec).</p>

<p>Compile time of typical grammars like the accompaying C grammar should
be fractions of a second for both the LALR(1) and LR(1) method. (Just
type (buffalo:make-parser buffalo::cgrammar) or (buffalo:make-parser
buffalo::cgrammar :canonical-lr1 t) at your REPL for a first
impression.)</p>

<p>Compile times with sbcl are:</p>

<p>Grammar       | LALR          | canonical LR(1)
&mdash;&mdash;&mdash;&mdash;- |:&mdash;&mdash;&mdash;&mdash;-:|:&mdash;&mdash;&mdash;&mdash;-:
C             | 0.04s         | 0.24s
Ada           | 0.09s         | 0.64s</p>

<p>Buffalo is quickload-able (just type (ql:quickload &apos;buffalo) at your
REPL) and is tested with sbcl, ccl and clisp, but should work with
every conformant implementation. The version in quicklisp might not
reflect the latest changes, though.</p>

<p>Buffalo implements all of the functionality and all of the user
interface functions and macros of cl-yacc (on whose API code it is in
part built). Software that runs with cl-yacc should work with buffalo
without modification.</p>

<p>Features:
- Very fast, scalable table construction
- Simple compilation model for seamless integration with Lisp
- Comprehensive grammar checks
- Basic Export/Import facilities to and from POSIX yacc
- yacc conflict resolution mechanism</p>

<p>Current limitations:
- No &ldquo;error&rdquo; productions
- No mid-rule actions
- No lexer</p>

<h2>Examples</h2>

<h3>Buffalo-tests</h3>

<p>This package contains various small grammars (right- and left-recursive,
ambigious with left or right precedence or non-associativity, of LALR(1) or
LR(1) type).</p>

<h3>Upstream integration</h3>

<p>There is a separate project <a href="https://github.com/fhuttner/e2bnf" >e2bnf</a>
that allows one to create AST builder directly from a grammar
specification by transforming an extended grammar to the BNF form
expected by buffalo.</p>

<h3>Parser factory</h3>

<p>It shows how semantic actions can be modified programatically
even though the parser is defined by a macro at compile time:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> parser-factory <span class="paren2">(<span class="code">plus times</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">def-parser</span></i>
    <span class="paren3">(<span class="code"><span class="keyword">:terminals</span> <span class="paren4">(<span class="code">+ * id lb rb</span>)</span></span>)</span>  <span class="comment">; lb = '(', rb = ')'
</span>    <span class="paren3">(<span class="code"><span class="keyword">:start-symbol</span> e</span>)</span>
    <span class="paren3">(<span class="code">e
     <span class="paren4">(<span class="code">e + tt <span class="paren5">(<span class="code">values plus</span>)</span></span>)</span>
     tt</span>)</span>
    <span class="paren3">(<span class="code">tt
     <span class="paren4">(<span class="code">tt * f <span class="paren5">(<span class="code">values times</span>)</span></span>)</span>
     f</span>)</span>
    <span class="paren3">(<span class="code">f
     <span class="paren4">(<span class="code">lb e rb <span class="paren5">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren6">(<span class="code">lb e rb</span>)</span>
        <span class="paren6">(<span class="code">declare <span class="paren1">(<span class="code">ignore lb rb</span>)</span></span>)</span> e</span>)</span></span>)</span>
     id</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> test-parser-factory <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">list '<span class="paren5">(<span class="code">lb id + id * id rb</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">flet</span></i> <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">list-lexer <span class="paren6">(<span class="code">list</span>)</span>
         <span class="paren6">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren1">(<span class="code"></span>)</span>
           <span class="paren1">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">x <span class="paren4">(<span class="code">pop list</span>)</span></span>)</span></span>)</span>
         <span class="paren2">(<span class="code">values x x</span>)</span></span>)</span></span>)</span></span>)</span>
       <span class="paren5">(<span class="code">plus <span class="paren6">(<span class="code">a p b</span>)</span>
         <span class="paren6">(<span class="code">declare <span class="paren1">(<span class="code">ignore p</span>)</span></span>)</span>
         `<span class="paren6">(<span class="code">+ ,a ,b</span>)</span></span>)</span>
       <span class="paren5">(<span class="code">times <span class="paren6">(<span class="code">a p b</span>)</span>
         <span class="paren6">(<span class="code">declare <span class="paren1">(<span class="code">ignore p</span>)</span></span>)</span>
         `<span class="paren6">(<span class="code">* ,a ,b</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren5">(<span class="code"><span class="paren6">(<span class="code">a <span class="paren1">(<span class="code">parser-factory #'list #'list</span>)</span></span>)</span>
        <span class="paren6">(<span class="code">b <span class="paren1">(<span class="code">parser-factory #'plus #'times</span>)</span></span>)</span></span>)</span>
    <span class="comment">;; print as infix: &gt; (ID + (ID * ID))
</span>    <span class="paren5">(<span class="code">print
     <span class="paren6">(<span class="code">parse-with-lexer <span class="paren1">(<span class="code">list-lexer list</span>)</span> a</span>)</span></span>)</span>
    <span class="comment">;; print as prefix: &gt; (+ ID (* ID ID))
</span>    <span class="paren5">(<span class="code">print
     <span class="paren6">(<span class="code">parse-with-lexer <span class="paren1">(<span class="code">list-lexer list</span>)</span> b</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>Torture test</h3>

<p>For license reasons there is a separate project
<a href="https://github.com/fhuttner/buffalo-testsuite" >buffalo-testsuite</a>
that demonstrates that buffalo can build parsers for grammars with
many thousand tokens and productions, and in time and space
requirements comparable to GNU Bison.</p>
